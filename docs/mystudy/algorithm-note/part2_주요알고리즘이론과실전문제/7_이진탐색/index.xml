<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>7. 이진탐색 on 이세상의 모든 노트</title>
    <link>https://yera10.github.io/docs/mystudy/algorithm-note/part2_%EC%A3%BC%EC%9A%94%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B4%EB%A1%A0%EA%B3%BC%EC%8B%A4%EC%A0%84%EB%AC%B8%EC%A0%9C/7_%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89/</link>
    <description>Recent content in 7. 이진탐색 on 이세상의 모든 노트</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://yera10.github.io/docs/mystudy/algorithm-note/part2_%EC%A3%BC%EC%9A%94%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B4%EB%A1%A0%EA%B3%BC%EC%8B%A4%EC%A0%84%EB%AC%B8%EC%A0%9C/7_%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://yera10.github.io/docs/mystudy/algorithm-note/part2_%EC%A3%BC%EC%9A%94%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B4%EB%A1%A0%EA%B3%BC%EC%8B%A4%EC%A0%84%EB%AC%B8%EC%A0%9C/7_%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://yera10.github.io/docs/mystudy/algorithm-note/part2_%EC%A3%BC%EC%9A%94%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B4%EB%A1%A0%EA%B3%BC%EC%8B%A4%EC%A0%84%EB%AC%B8%EC%A0%9C/7_%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89/readme/</guid>
      <description>이진탐색#1. 범위를 반씩 좁혀가는 탐색#순차탐색#N개의 데이터가 있을 때, 그 데이터를 하나씩 확인하며 어떠한 처리를 해준 것이 순차 탐색 그자체 순차 탐색이란 리스트 안에 있는 특정한 데이터를 찾기 위해 앞에서부터 데이터를 하나씩 차례대로 확인하는 방법 보통 정렬되지 않은 리스트에서 데이터를 찾아야 할 때 사용한다. 순차 탐색은 리스트에 특정 값의 원소가 있는지 체크할 때도 쓰며, 리스트 자료형에서 특정한 원소의 개수를 세는 count() 메서드를 사용할 때도 쓰인다.</description>
    </item>
    <item>
      <title></title>
      <link>https://yera10.github.io/docs/mystudy/algorithm-note/part2_%EC%A3%BC%EC%9A%94%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B4%EB%A1%A0%EA%B3%BC%EC%8B%A4%EC%A0%84%EB%AC%B8%EC%A0%9C/7_%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89/%EB%AC%B8%EC%A0%9C_%EB%96%A1%EB%B3%B6%EC%9D%B4%EB%96%A1%EB%A7%8C%EB%93%A4%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://yera10.github.io/docs/mystudy/algorithm-note/part2_%EC%A3%BC%EC%9A%94%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B4%EB%A1%A0%EA%B3%BC%EC%8B%A4%EC%A0%84%EB%AC%B8%EC%A0%9C/7_%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89/%EB%AC%B8%EC%A0%9C_%EB%96%A1%EB%B3%B6%EC%9D%B4%EB%96%A1%EB%A7%8C%EB%93%A4%EA%B8%B0/</guid>
      <description>떡볶이 떡 만들기#INPUT#첫째줄: N, M = 떡의 개수, 요청한 떡의 길이
($1\le N \le 1,000,000, 1\le M \le 2,000,000,000$) 둘째줄: 떡의 개별 높이 떡의 개별 높이의 총합은 항상 M 이상. 높이는 1,000,000,000보다 작거나 같은 양의 정수 또는 0 OUTPUT#적어도 M만큼 떡을 가져가기 위해 절단기에 설정할 수 있는 높이의 최댓값 Example#문제#절단기에 높이 H를 설정하면, 높이가 H보다 긴 떡만 H 위의 부분이 잘림.</description>
    </item>
    <item>
      <title></title>
      <link>https://yera10.github.io/docs/mystudy/algorithm-note/part2_%EC%A3%BC%EC%9A%94%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B4%EB%A1%A0%EA%B3%BC%EC%8B%A4%EC%A0%84%EB%AC%B8%EC%A0%9C/7_%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89/%EB%AC%B8%EC%A0%9C_%EB%B6%80%ED%92%88%EC%B0%BE%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://yera10.github.io/docs/mystudy/algorithm-note/part2_%EC%A3%BC%EC%9A%94%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B4%EB%A1%A0%EA%B3%BC%EC%8B%A4%EC%A0%84%EB%AC%B8%EC%A0%9C/7_%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89/%EB%AC%B8%EC%A0%9C_%EB%B6%80%ED%92%88%EC%B0%BE%EA%B8%B0/</guid>
      <description>부품 찾기#INPUT#$N$ : 탐색할 배열의 크기 ($1 \le N \le 1,000,000$) 공백으로 구분된 N개의 정수: 탐색할 배열, $1 &amp;lt; 정수 \le 1,000,000$ $M$ : 찾으려는 숫자의 갯수 ($1 \le M \le 100,000$) 공백으로 구분된 M개의 정수: 탐색할 값, ($1 &amp;lt; N \le 1,000,000$) OUTPUT#찾으려는 값들의 존재 여부를 yes, no로 출력 Example#Input Output 58 3 7 9 235 7 9 no yes yes My Solution## SOLUTION def binary_search(arr, target, s, e): if e &amp;lt; s: return -1 m = (s+e)//2 if arr[m] &amp;lt; target: return binary_search(arr, target, m+1, e) elif arr[m] &amp;gt; target: return binary_search(arr, target, s, m-1) else: return arr[m] def solution(arr, targets, N): arr.</description>
    </item>
    <item>
      <title></title>
      <link>https://yera10.github.io/docs/mystudy/algorithm-note/part2_%EC%A3%BC%EC%9A%94%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B4%EB%A1%A0%EA%B3%BC%EC%8B%A4%EC%A0%84%EB%AC%B8%EC%A0%9C/7_%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89/%EC%A7%95%EA%B2%80%EB%8B%A4%EB%A6%AC%EA%B1%B4%EB%84%88%EA%B8%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://yera10.github.io/docs/mystudy/algorithm-note/part2_%EC%A3%BC%EC%9A%94%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%B4%EB%A1%A0%EA%B3%BC%EC%8B%A4%EC%A0%84%EB%AC%B8%EC%A0%9C/7_%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89/%EC%A7%95%EA%B2%80%EB%8B%A4%EB%A6%AC%EA%B1%B4%EB%84%88%EA%B8%B0/</guid>
      <description>프로그래머스 - 징검다리 건너기#문제 링크 : 링크
Input#디딤돌에 적힌 숫자가 순서대로 담긴 배열 stones 한 번에 건너뛸 수 있는 디딤돌의 최대 칸수 k 디딤돌에는 모두 숫자가 적혀 있으며 디딤돌의 숫자는 한 번 밟을 때마다 1씩 줄어듭니다. 디딤돌의 숫자가 0이 되면 더 이상 밟을 수 없으며 이때는 그 다음 디딤돌로 한번에 여러 칸을 건너 뛸 수 있습니다. 단, 다음으로 밟을 수 있는 디딤돌이 여러 개인 경우 무조건 가장 가까운 디딤돌로만 건너뛸 수 있습니다 Output#최대 몇 명까지 징검다리를 건널 수 있는지 return 입력과 출력 예#stones k result [2, 4, 5, 3, 2, 1, 4, 2, 5, 1] 3 3 나의 풀이 코드#통과 (313.</description>
    </item>
  </channel>
</rss>
