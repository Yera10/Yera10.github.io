<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>6. 정렬 on 이세상의 모든 노트</title>
    <link>https://yera10.github.io/docs/mystudy/algorithm-note/part2/6_%EC%A0%95%EB%A0%AC/</link>
    <description>Recent content in 6. 정렬 on 이세상의 모든 노트</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://yera10.github.io/docs/mystudy/algorithm-note/part2/6_%EC%A0%95%EB%A0%AC/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title></title>
      <link>https://yera10.github.io/docs/mystudy/algorithm-note/part2/6_%EC%A0%95%EB%A0%AC/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://yera10.github.io/docs/mystudy/algorithm-note/part2/6_%EC%A0%95%EB%A0%AC/readme/</guid>
      <description>정렬#데이터를 특정한 기준에 따라 나열하는 것 프로그램 작성할 때 가장 많이 사용되는 알고리즘 이진탐색의 전처리 과정이기도 함 알고리즘의 효율성을 쉽게 이해할 수 있음 일반적으로 문제에서 요구하는 조건에 따라 적절한 정렬 알고리즘이 공식처럼 사용된다. 정렬 알고리즘의 종류#선택 정렬 삽입 정렬 퀵 정렬 계수 정렬 파이썬의 기본 정렬 라이브러리로 더 효과적인 정렬 하기#정렬 알고리즘은 이 밖에도 매우 다양한 종류가 있음. 정렬 알고리즘을 직접 작성하게 되는 경우도 있지만, 미리 만들어진 라이브러리를 이용하는 것이 효과적인 경우가 더 많다.</description>
    </item>
    <item>
      <title></title>
      <link>https://yera10.github.io/docs/mystudy/algorithm-note/part2/6_%EC%A0%95%EB%A0%AC/%EA%B3%84%EC%88%98%EC%A0%95%EB%A0%AC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://yera10.github.io/docs/mystudy/algorithm-note/part2/6_%EC%A0%95%EB%A0%AC/%EA%B3%84%EC%88%98%EC%A0%95%EB%A0%AC/</guid>
      <description>계수 정렬#특정한 조건이 부합할 때만 사용할 수 있지만, 매우 빠른 정렬 알고리즘 데이터가 모두 양의 정수이며, 데이터의 개수가 N, 최댓값이 K일 때, 계수 정렬은 최악의 경우에도 수행시간 $O(N+K)$을 보장함 매우 빠르게 동작하며, 매우 간단한 원리 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때만 사용 가능 실수형 데이터로 주어질 때 사용하기 어려움 일반적으로는 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000을 넘지 않을 때 효과적 데이터의 범위가 너무 크면 계수정렬을 사용할 수 없음.</description>
    </item>
    <item>
      <title></title>
      <link>https://yera10.github.io/docs/mystudy/algorithm-note/part2/6_%EC%A0%95%EB%A0%AC/%EC%82%BD%EC%9E%85%EC%A0%95%EB%A0%AC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://yera10.github.io/docs/mystudy/algorithm-note/part2/6_%EC%A0%95%EB%A0%AC/%EC%82%BD%EC%9E%85%EC%A0%95%EB%A0%AC/</guid>
      <description>삽입정렬#데이터를 하나씩 확인하며, 각 데이터의 적절한 위치에 삽입하면 어떨까? 선택정렬에 비해 구현 난이도가 높은 편이지만, 실행 시간 측면에서 더 효율적인 알고리즘 특히 삽입 정렬은 필요할 때만 위치를 바꾸기 때문에 &amp;ldquo;데이터가 거의 정렬되어 있을 때&amp;rdquo; 효율적 특정한 데이터를 적절한 위치에 &amp;ldquo;삽입&amp;quot;한다는 의미 삽입정렬 방법 특정한 데이터가 적절한 위치에 들어가기 이전에 그 앞까지의 데이터는 이미 정렬되어 있다고 가정 정렬되어 있는 리스트에 적절한 위치를 찾은 뒤, 그 위치에 삽입 특정 데이터가 삽입될 위치를 선정할 때(왼쪽으로 한 칸씩 이동하며 탐색할 때), 삽입될 데이터보다 작은 데이터를 만나면, 그 위치에서 멈춤 삽입정렬 소스코드</description>
    </item>
    <item>
      <title></title>
      <link>https://yera10.github.io/docs/mystudy/algorithm-note/part2/6_%EC%A0%95%EB%A0%AC/%EC%84%A0%ED%83%9D%EC%A0%95%EB%A0%AC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://yera10.github.io/docs/mystudy/algorithm-note/part2/6_%EC%A0%95%EB%A0%AC/%EC%84%A0%ED%83%9D%EC%A0%95%EB%A0%AC/</guid>
      <description>선택 정렬#매번 가장 작은 것을 선택한다는 의미의 알고리즘 가장 작은 데이터를 맨 앞에 있는 데이터와 바꾸고,
그 다음 작은 데이터를 두 번째 데이터와 바꾸고 &amp;hellip; 이런 과정을 반복 # INPUT arr = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8] # SOLUTION def select_sorting(arr): for i in range(len(arr)): min_i = i for j in range(i+1, len(arr)): if arr[j] &amp;lt; arr[min_i]: min_i = j arr[i], arr[min_i] = arr[min_i], arr[i] # OUTPUT select_sorting(arr) print(arr) 선택 정렬의 시간복잡도는 $N + (N-1) + \dots + 2$ 로 $O(N^2)$ 이다.</description>
    </item>
    <item>
      <title></title>
      <link>https://yera10.github.io/docs/mystudy/algorithm-note/part2/6_%EC%A0%95%EB%A0%AC/%EC%84%B1%EC%A0%81%EC%9D%B4%EB%82%AE%EC%9D%80%EC%88%9C%EC%84%9C%EB%A1%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://yera10.github.io/docs/mystudy/algorithm-note/part2/6_%EC%A0%95%EB%A0%AC/%EC%84%B1%EC%A0%81%EC%9D%B4%EB%82%AE%EC%9D%80%EC%88%9C%EC%84%9C%EB%A1%9C/</guid>
      <description>성적이 낮은 순서로 학생 출력하기#INPUT#첫번째 줄 - 학생 수 N (1&amp;lt;=N&amp;lt;=100,000) 학생의 이름 문자열 A, 학생의 성적 B가 공백으로 구분되어 입력 학생의 성적 B는 100이하의 자연수 학생의 이름 A는 100 이하의 길이 OUTPUT#모든 학생의 이름을 성적이 낮은 순서대로 출력 성적이 동일한 학생의 순서는 자유롭게 출력 My Solution## SOLUTION def solution(scores): sorted_list = [[] for _ in range(101)] for n, s in scores: sorted_list[s].</description>
    </item>
    <item>
      <title></title>
      <link>https://yera10.github.io/docs/mystudy/algorithm-note/part2/6_%EC%A0%95%EB%A0%AC/%EC%9C%84%EC%97%90%EC%84%9C%EC%95%84%EB%9E%98%EB%A1%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://yera10.github.io/docs/mystudy/algorithm-note/part2/6_%EC%A0%95%EB%A0%AC/%EC%9C%84%EC%97%90%EC%84%9C%EC%95%84%EB%9E%98%EB%A1%9C/</guid>
      <description>위에서 아래로#INPUT#첫째줄 - 수열에 속해있는 수의 개수 N, (1 &amp;lt;= N &amp;lt;= 500) 둘째줄부터 N개의 수 입력됨 (범위 1~100,000의 자연수) OUTPUT#입력으로 주어진 수열이 내림차순으로 정렬된 결과를 공백으로 구분하여 출력 Example#INPUT OUTPUT 3152712 27 15 12 My Solution## SOLUTION def solution(arr): cnt_list = [0 for _ in range(100001)] for v in arr: cnt_list[v] += 1 for i in range(100000, -1, -1): for _ in range(cnt_list[i]): print(i, end=&amp;#39; &amp;#39;) # TEST N = int(input()) arr = [] for _ in range(N): arr.</description>
    </item>
    <item>
      <title></title>
      <link>https://yera10.github.io/docs/mystudy/algorithm-note/part2/6_%EC%A0%95%EB%A0%AC/%ED%80%B5%EC%A0%95%EB%A0%AC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://yera10.github.io/docs/mystudy/algorithm-note/part2/6_%EC%A0%95%EB%A0%AC/%ED%80%B5%EC%A0%95%EB%A0%AC/</guid>
      <description>퀵 정렬#정렬 알고리즘 중 가장 많이 사용되는 알고리즘
퀵 정렬과 비교할만큼 빠른 알고리즘으로 &amp;lsquo;병합 정렬&amp;rsquo;이 있음.
퀵 정렬과 병합 정렬은 대부분의 프로그래밍 언어에서 정렬 라이브러리의 근간이 되는 알고리즘이기도 함.
기준을 설정한 다음 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식으로 동작
퀵 정렬에서는 피벗(Pivot)이 사용된다.
큰 숫자와 작은 숫자를 교환할 때, 교환하기 위한 &amp;lsquo;기준&amp;rsquo;을 피벗이라고 표현
피벗을 어떻게 설정하고 리스트를 분할하는지에 따라 여러 가지 방식의 퀵 정렬이 있다.</description>
    </item>
  </channel>
</rss>
