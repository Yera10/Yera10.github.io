<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>7. 이진탐색 on 이세상의 모든 노트</title><link>https://yera10.github.io/docs/mystudy/algorithm-note/part2/7_%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89/</link><description>Recent content in 7. 이진탐색 on 이세상의 모든 노트</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://yera10.github.io/docs/mystudy/algorithm-note/part2/7_%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://yera10.github.io/docs/mystudy/algorithm-note/part2/7_%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89/%EB%96%A1%EB%B3%B6%EC%9D%B4%EB%96%A1%EB%A7%8C%EB%93%A4%EA%B8%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/mystudy/algorithm-note/part2/7_%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89/%EB%96%A1%EB%B3%B6%EC%9D%B4%EB%96%A1%EB%A7%8C%EB%93%A4%EA%B8%B0/</guid><description>떡볶이 떡 만들기 # INPUT # 첫째줄: N, M = 떡의 개수, 요청한 떡의 길이
($1\le N \le 1,000,000, 1\le M \le 2,000,000,000$) 둘째줄: 떡의 개별 높이 떡의 개별 높이의 총합은 항상 M 이상. 높이는 1,000,000,000보다 작거나 같은 양의 정수 또는 0 OUTPUT # 적어도 M만큼 떡을 가져가기 위해 절단기에 설정할 수 있는 높이의 최댓값 Example # 문제 # 절단기에 높이 H를 설정하면, 높이가 H보다 긴 떡만 H 위의 부분이 잘림.</description></item><item><title/><link>https://yera10.github.io/docs/mystudy/algorithm-note/part2/7_%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89/%EB%B6%80%ED%92%88%EC%B0%BE%EA%B8%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/mystudy/algorithm-note/part2/7_%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89/%EB%B6%80%ED%92%88%EC%B0%BE%EA%B8%B0/</guid><description>부품 찾기 # INPUT # $N$ : 탐색할 배열의 크기 ($1 \le N \le 1,000,000$) 공백으로 구분된 N개의 정수: 탐색할 배열, $1 &amp;lt; 정수 \le 1,000,000$ $M$ : 찾으려는 숫자의 갯수 ($1 \le M \le 100,000$) 공백으로 구분된 M개의 정수: 탐색할 값, ($1 &amp;lt; N \le 1,000,000$) OUTPUT # 찾으려는 값들의 존재 여부를 yes, no로 출력 Example # Input Output 58 3 7 9 235 7 9 no yes yes My Solution # # SOLUTION def binary_search(arr, target, s, e): if e &amp;lt; s: return -1 m = (s+e)//2 if arr[m] &amp;lt; target: return binary_search(arr, target, m+1, e) elif arr[m] &amp;gt; target: return binary_search(arr, target, s, m-1) else: return arr[m] def solution(arr, targets, N): arr.</description></item><item><title/><link>https://yera10.github.io/docs/mystudy/algorithm-note/part2/7_%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89/%EC%A7%95%EA%B2%80%EB%8B%A4%EB%A6%AC%EA%B1%B4%EB%84%88%EA%B8%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/mystudy/algorithm-note/part2/7_%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89/%EC%A7%95%EA%B2%80%EB%8B%A4%EB%A6%AC%EA%B1%B4%EB%84%88%EA%B8%B0/</guid><description>프로그래머스 - 징검다리 건너기 # 문제 링크 : 링크
Input # 디딤돌에 적힌 숫자가 순서대로 담긴 배열 stones 한 번에 건너뛸 수 있는 디딤돌의 최대 칸수 k 디딤돌에는 모두 숫자가 적혀 있으며 디딤돌의 숫자는 한 번 밟을 때마다 1씩 줄어듭니다. 디딤돌의 숫자가 0이 되면 더 이상 밟을 수 없으며 이때는 그 다음 디딤돌로 한번에 여러 칸을 건너 뛸 수 있습니다. 단, 다음으로 밟을 수 있는 디딤돌이 여러 개인 경우 무조건 가장 가까운 디딤돌로만 건너뛸 수 있습니다 Output # 최대 몇 명까지 징검다리를 건널 수 있는지 return 입력과 출력 예 # stones k result [2, 4, 5, 3, 2, 1, 4, 2, 5, 1] 3 3 나의 풀이 코드 # 통과 (313.</description></item></channel></rss>