<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on 이세상의 모든 노트</title><link>https://yera10.github.io/</link><description>Recent content in Introduction on 이세상의 모든 노트</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://yera10.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://yera10.github.io/docs/mystudy/deep-learning-study/historical_review/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/mystudy/deep-learning-study/historical_review/</guid><description>Historical Review # 2012 - AlexNet (패러다임 쇼크!) 2013 - DQN (알파고를 만든 알고리즘) 2014 - Encoder/Decoder, Adam 2015 - GAN, ResNet 2016 - 2017 - Transformer (Attention Is All You Need) 2018 - Bert 2019 - Big Language Models (GPT-X) 2020 - Self-Supervised Learning (SimCLR) Further Reading and Reference
AlexNet (2012) # AlexNet은 딥러닝과 AI 연구의 붐을 일으킨 알고리즘으로 여겨졌다 Yann LeCun이 개발한 초기 LeNet에 기초한 CNN이다 알고리즘을 발전시키고, GPU 성능을 통해 기존 방법들 보다 ImageNet 데이터를 분류하는데 훨씬 뛰어난 성능을 보였다.</description></item><item><title>셋팅 및 시작</title><link>https://yera10.github.io/docs/mystudy/hugo-blog/1_%EC%84%A4%EC%B9%98/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/mystudy/hugo-blog/1_%EC%84%A4%EC%B9%98/</guid><description>Intro # Ref # https://github.com/Integerous/Integerous.github.io
https://ialy1595.github.io/post/blog-construct-1/
How to # 1. Hugo 설치 # hugo 공식깃헙에서 다운로드
윈도우를 사용하고, 추가 기능이 필요할지 몰라 extended 버전인 hugo_extended_0.121.0_windows-amd64을 받았다. C:\Hugo\bin 디렉토리 생성해서 다운받은 압축파일 해제 환경변수에 Hugo 영구적으로 추가 $ setx PATH=%PATH%C:\Hugo\bin; hugo 실행 확인
hugo version 또는 hugo help 명령어 2. Gihub 레포 셋팅 # Blog 저장소 Private으로 생성 (저장소명 다르게해도 됨) &amp;lt;USERNAME&amp;gt;.github.io 저장소 생성 Blog 레포를 로컬에 clone한다. git clone https://github.</description></item><item><title>AlexNet</title><link>https://yera10.github.io/docs/mystudy/deep-learning-study/alexnet/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/mystudy/deep-learning-study/alexnet/</guid><description>AlexNet # 논문 요약 정리
Abstract # ImageNet LSVRC-2010 (1,200,000장의 고해상도 이미지들)를 1000개의 클래스로 분류하는 CNN 모델 기존 SOTA보다 향상된 성능 6천만개의 파라미터, 65만개의 뉴런으로 이루어져있고, 5개의 Conv-layer와 3개의 FC-layer로 구성되어있다. (최종은 1000-way softmax) 빠르게 훈련시키기 위해 비포화 뉴런과 GPU 구현을 사용 FC-layer에서 오버피팅을 줄이기 위해 dropout 방법 적용 또한, Alexnet의 변형은 ILSVRC-2012에서 오류율 15.3%로 우승한 딥러닝 신경망 아키텍처이다. Introduction # 이 논문의 기여도 ImageNet데이터로 훈련한 CNN모델로 이 데이터셋에 대한 최고의 성능에 달성 2D conv에 최적화된 GPU 구현과 공개 성능을 향상시키고 훈련시간을 단축시키는 몇 가지 특징들이 있다 (Section 3) 오버피팅을 방지하는 몇 가지 기술들 (Section 4) 이당시 2개의 GTX 580 3GB GPUs로 훈련했을 때, 5~6일 소요됐다.</description></item><item><title>컨텐츠 연결</title><link>https://yera10.github.io/docs/mystudy/hugo-blog/2_%EC%BB%A8%ED%85%90%EC%B8%A0%EC%97%B0%EA%B2%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/mystudy/hugo-blog/2_%EC%BB%A8%ED%85%90%EC%B8%A0%EC%97%B0%EA%B2%B0/</guid><description> git 서브모듈 사용하여 컨텐츠 연결 # 나는 기존에 깃헙레포를 노트처럼 사용하면서 공부한 내용들을 적어두고 있었다 그래서 그 레포를 블로그에 연결하고자 submodule을 사용했다.
1. 컨텐츠 디렉토리로 이동 # cd content/docs 2. 저장소 submodule로 추가 # git submodule add {저장소의 URL} 3. 변경내용 add, commit, push # cd Blog/ git add . git commit -m &amp;#34;{커밋메시지}&amp;#34; git push</description></item><item><title>자동 업로드</title><link>https://yera10.github.io/docs/mystudy/hugo-blog/3_%EC%9E%90%EB%8F%99%EC%97%85%EB%A1%9C%EB%93%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/mystudy/hugo-blog/3_%EC%9E%90%EB%8F%99%EC%97%85%EB%A1%9C%EB%93%9C/</guid><description>Github Action을 사용하여 컨텐츠 업로드 자동화하기 # ref # 코드인용
action 공부
https://somaz.tistory.com/213#google_vignette
https://fe-developers.kakaoent.com/2022/220106-github-actions/
https://velog.io/@adam2/Github-Action-%EC%A3%BC%EC%9A%94-%EB%AC%B8%EB%B2%95
https://kotlinworld.com/400
1. 토큰 발급 # https://github.com 에서 우측 상단 프로필 클릭 Settings 클릭 좌측 바 하단의 Developer Settings 클릭 Personal access tockens 클릭 Generate new token 클릭 블로그 관련 모든 레포에 대한 권한을 부여한 토큰 생성 토큰 복사 2. Secret 등록 # github에서 Blog 저장소 접속 상단 바에서 Settings 클릭 좌측 네비게이션 바에서 Secrets and variables &amp;gt; Actions 클릭 New repository secret 클릭 NAME은 TOKEN으로 Secret에는 복사한 토큰을 붙여넣기 하여 등록 서브모듈 저장소들에도 위와 같은 방법으로 Secret 등록 2.</description></item><item><title/><link>https://yera10.github.io/docs/memo/commands/etc/docker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/memo/commands/etc/docker/</guid><description> docker 버전 확인 # docker -v docker image 검색 및 설치 # docker search ubuntu docker pull ubuntu:20.04 컨테이너 생성 및 실행 # docker run -it --name &amp;lt;이름&amp;gt; &amp;lt;Image이름&amp;gt; /bin/bash 컨테이너 목록 확인 # docker ps --all</description></item><item><title/><link>https://yera10.github.io/docs/memo/commands/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/memo/commands/readme/</guid><description>Git 관련 # commit 취소
credentail 관련
clone 관련
최초 설정 관련
Linux # 파일 생성/이동/복사/삭제
백그라운드 관련 명령어
Ubuntu Screen 명령어
GPU 관련
압축해제
conda # 가상환경 관련
Poetry # Poetry 시작하기
가상환경 관련
의존성 관련
내보내기(requirements.txt)
기타 # python3의 venv 사용법
python3 서버열기
python의 인자값 받기
Docker 명령어
VSCode 단축키
터미널 테마</description></item><item><title/><link>https://yera10.github.io/docs/mystudy/algorithm-note/part2/3_%EA%B7%B8%EB%A6%AC%EB%94%94/1%EC%9D%B4%EB%90%A0%EB%95%8C%EA%B9%8C%EC%A7%80/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/mystudy/algorithm-note/part2/3_%EA%B7%B8%EB%A6%AC%EB%94%94/1%EC%9D%B4%EB%90%A0%EB%95%8C%EA%B9%8C%EC%A7%80/</guid><description>1이 될 때까지 # INPUT # 2 &amp;lt;= N &amp;lt;= 100,000 2 &amp;lt;= K &amp;lt;= 100,000 N &amp;gt;= K OUTPUT # N이 1이 될 때까지 수행해야 하는 과정의 최소 횟수 출력 Rule # 둘 중 하나의 과정을 반복적으로 수행 2번 과정은 N이 K로 나누어 떨어질 때만 선택 가능 N에서 1을 뺀다. N을 K로 나눈다. Example # 입력 출력 25 5 2 17 4 3 My Solution # 2번이 가능하면 2번을 수행하는 게 가장 빠른 방법 연상되는 이유는 더 크게 줄어들기 때문에 1번을 선택했을 때, 2번보다 빠르려면, 1번을 수행한 수가 K로 나누어 떨어질 때 =&amp;gt; 그러려면 K가 1이어야 한다?</description></item><item><title/><link>https://yera10.github.io/docs/mystudy/algorithm-note/part2/3_%EA%B7%B8%EB%A6%AC%EB%94%94/%EC%88%AB%EC%9E%90%EC%B9%B4%EB%93%9C%EA%B2%8C%EC%9E%84/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/mystudy/algorithm-note/part2/3_%EA%B7%B8%EB%A6%AC%EB%94%94/%EC%88%AB%EC%9E%90%EC%B9%B4%EB%93%9C%EA%B2%8C%EC%9E%84/</guid><description>숫자 카드 게임 # Input # N, M : 숫자카드들의 행, 열의 개수, 첫째줄에 주어짐 1 &amp;lt;= N, M &amp;lt;= 100 각 카드에 적힌 숫자들, 둘째줄부터 주어짐 1 &amp;lt;= 각 숫자 &amp;lt;= 10,000 Output # 게임의 룰에 맞게 선택한 카드에 적힌 숫자 Rule # 숫자카드들이 N x M 형태로 놓여있음 뽑고자 하는 카드가 포함되어 있는 행 선택 선택된 행에서 가장 작은 숫자카드를 뽑음 어떤 행을 선택해야 가장 높은 숫자의 카드를 뽑을 수 있을까?</description></item><item><title/><link>https://yera10.github.io/docs/mystudy/algorithm-note/part2/3_%EA%B7%B8%EB%A6%AC%EB%94%94/%ED%81%B0%EC%88%98%EC%9D%98%EB%B2%95%EC%B9%99/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/mystudy/algorithm-note/part2/3_%EA%B7%B8%EB%A6%AC%EB%94%94/%ED%81%B0%EC%88%98%EC%9D%98%EB%B2%95%EC%B9%99/</guid><description>큰 수의 법칙 # Input # N : 2 $\leq$ N $\leq$ 1,000, 배열의 크기 M : 1 $\leq$ M $\leq$ 10,000, 숫자가 더해지는 횟수 K : 1 $\leq$ K $\leq$ 10,000, 특정 인덱스의 수가 연속해서 더해질 수 있는 횟수 array : 주어진 배열 항상 K &amp;lt;= M 큰 수의 법칙 # 배열의 숫자들을 M 번 더하여 가장 큰 수를 만드는 법칙 특정한 인덱스에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없다.</description></item><item><title/><link>https://yera10.github.io/docs/mystudy/algorithm-note/part2/4_%EA%B5%AC%ED%98%84/%EA%B2%8C%EC%9E%84-%EA%B0%9C%EB%B0%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/mystudy/algorithm-note/part2/4_%EA%B5%AC%ED%98%84/%EA%B2%8C%EC%9E%84-%EA%B0%9C%EB%B0%9C/</guid><description>게임 개발 # Input # N, M : 세로 크기, 가로 크기 (3 &amp;lt;= N,M &amp;lt;= 50) A, B, d : 게임 캐릭터가 있는 칸의 좌표 (A, B), 캐릭터가 바라보는 방향 d d 값 : 0 : 북 1 : 동 2 : 남 3 : 서 맵의 정보 : 육지인지 바다인지 N x M 으로 나타내줌 0 : 육지 1 : 바다 맵의 외곽은 항상 바다 게임 캐릭터가 처음 위치한 칸의 정보는 항상 육지 Output # 첫째 줄에 이동을 마친 후 캐릭터가 방문한 칸의 수 Rule # 현재 위치에서 현재 방향을 기준으로 반시계방향부터 차례대로 갈 곳을 정함 캐릭터의 왼쪽 방향(반시계 방향)에 가보지 않은 칸이 있다면, 왼쪽 방향으로 회전한 다음 왼쪽으로 한칸 전진.</description></item><item><title/><link>https://yera10.github.io/docs/mystudy/algorithm-note/part2/4_%EA%B5%AC%ED%98%84/%EC%83%81%ED%95%98%EC%A2%8C%EC%9A%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/mystudy/algorithm-note/part2/4_%EA%B5%AC%ED%98%84/%EC%83%81%ED%95%98%EC%A2%8C%EC%9A%B0/</guid><description>상하좌우 # Input # N : 공간의 크기, N x N 크기의 정사각형 공간 이동할 계획서 : 여행가가 N x N 공간에서 이동할 계획, (1&amp;lt;= 이동횟수 &amp;lt;=100) Output # 여행가가 최종적으로 도착할 지점의 좌표를 공백으로 구분하여 출력 이동할 때, N x N의 정사각형을 벗어나는 움직임은 무시됨 예를 들어, (1,1)에서 L 혹은 U의 움직임은 무시 Example # 입력 출력 5 R R R U D D 3 4 My Solution # def solution(N, moves): now = [1, 1] moves = moves.</description></item><item><title/><link>https://yera10.github.io/docs/mystudy/algorithm-note/part2/4_%EA%B5%AC%ED%98%84/%EC%8B%9C%EA%B0%81/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/mystudy/algorithm-note/part2/4_%EA%B5%AC%ED%98%84/%EC%8B%9C%EA%B0%81/</guid><description>시각 # Input # N : 정수, 0&amp;lt;= N &amp;lt;= 23 Output # 00시 00분 00초부터 N시 59분 59초 까지의 모든 시각 중 3이 하나라도 포함되는 모든 경우의수 출력 Example # 입력 출력 5 11475 My Solution # def solution(N): res = 0 for h in range(N+1): if &amp;#39;3&amp;#39; in str(h): res += 60*60 continue for m in range(60): if &amp;#39;3&amp;#39; in str(m): res += 60 continue for s in range(60): if &amp;#39;3&amp;#39; in str(s): res += 1 return res N = 5 print(solution(N)) 문제 해설 # 하루는 86,400초로 모든 경우는 86,400가지밖에 존재하지 않음.</description></item><item><title/><link>https://yera10.github.io/docs/mystudy/algorithm-note/part2/4_%EA%B5%AC%ED%98%84/%EC%99%95%EC%8B%A4%EC%9D%98%EB%82%98%EC%9D%B4%ED%8A%B8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/mystudy/algorithm-note/part2/4_%EA%B5%AC%ED%98%84/%EC%99%95%EC%8B%A4%EC%9D%98%EB%82%98%EC%9D%B4%ED%8A%B8/</guid><description> 왕실의 나이트 # Input # 8 x 8 좌표평면에서 나이트가 현재 위치한 곳의 좌표 두문자로 구성된 문자열 Output # 나이트가 이동할 수 있는 경우의 수 Example # 입력 출력 a1 2 My Solution # moves = [(2, 1), (2, -1), (-2, 1), (-2, 1), (1, 2), (1, -2), (-1, 2), (-1, -2)] def solution(x): c, r = ord(x[0])-96, int(x[1]) nx = [1 for m in moves if (0 &amp;lt; (c+m[0]) &amp;lt; 9) and (0 &amp;lt; (r+m[1]) &amp;lt; 9)] return sum(nx) x = input() print(solution(x)) 문제 해설 # # 현재 나이트 위치 입력 input_data = input() row = int(inpu_data[1]) column = int(ord(input_data[0])) - int(ord(&amp;#39;a&amp;#39;)) + 1 # 8가지 이동 steps = [(2, 1), (2, -1), (-2, 1), (-2, 1), (1, 2), (1, -2), (-1, 2), (-1, -2)] # 이동가능 여부 확인 result = 0 for step in steps: nrow = row + step[0] ncol = col + step[1] if 1 &amp;lt;= nrow &amp;lt;= 8 and 1&amp;lt;= ncol &amp;lt;= 8: result += 1 # 출력 print(result)</description></item><item><title/><link>https://yera10.github.io/docs/mystudy/algorithm-note/part2/5_dfs_bfs/%EB%AF%B8%EB%A1%9C%ED%83%88%EC%B6%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/mystudy/algorithm-note/part2/5_dfs_bfs/%EB%AF%B8%EB%A1%9C%ED%83%88%EC%B6%9C/</guid><description>미로탈출 # Input # 두 정수 N, M : 4 &amp;lt;= N, M &amp;lt;= 200 N개의 줄, M개의 정수로 미로정보 주어짐 공백 X 시작과 마지막은 항상 1 Output # 최소 이동 칸의 개수 Rule # N x M 크기의 직사각형 미로에 갇혀있다. 미로에 여러 마리의 괴물을 피해 탈출해야 함. 출발지점 (1,1)
출구위치 (N, M)
괴물이 있는 부분 : 0 \ 괴물이 없는 부분 : 1 \ 한번에 한칸씩 이동할 수 있음.</description></item><item><title/><link>https://yera10.github.io/docs/mystudy/algorithm-note/part2/5_dfs_bfs/%EC%9D%8C%EB%A3%8C%EC%88%98-%EC%96%BC%EB%A0%A4-%EB%A8%B9%EA%B8%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/mystudy/algorithm-note/part2/5_dfs_bfs/%EC%9D%8C%EB%A3%8C%EC%88%98-%EC%96%BC%EB%A0%A4-%EB%A8%B9%EA%B8%B0/</guid><description>음료수 얼려 먹기 # Input # 얼음 틀의 세로길이 N, 가로길이 M (1 &amp;lt;= N, M &amp;lt;= 1,000) 두번째 줄부터 N+1번째 줄까지 얼음 틀의 형태가 주어짐 구멍이 뚫려있는 부분은 0, 그렇지 않은 부분은 1 Output # 한 번에 만들 수 있는 아이스크림의 갯수 구하기 Example # 입력 출력 15 14 00000111100000 11111101111110 11011101101110 11011101100000 11011111111111 11011111111100 11000000011111 01111111111111 00000000011111 01111111111000 00011111111000 00000001111000 11111111110011 1110001111111111100011111111 8 My Solution # # INPUT n, m = map(int, input().</description></item><item><title/><link>https://yera10.github.io/docs/mystudy/algorithm-note/part2/6_%EC%A0%95%EB%A0%AC/%EC%84%B1%EC%A0%81%EC%9D%B4%EB%82%AE%EC%9D%80%EC%88%9C%EC%84%9C%EB%A1%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/mystudy/algorithm-note/part2/6_%EC%A0%95%EB%A0%AC/%EC%84%B1%EC%A0%81%EC%9D%B4%EB%82%AE%EC%9D%80%EC%88%9C%EC%84%9C%EB%A1%9C/</guid><description>성적이 낮은 순서로 학생 출력하기 # INPUT # 첫번째 줄 - 학생 수 N (1&amp;lt;=N&amp;lt;=100,000) 학생의 이름 문자열 A, 학생의 성적 B가 공백으로 구분되어 입력 학생의 성적 B는 100이하의 자연수 학생의 이름 A는 100 이하의 길이 OUTPUT # 모든 학생의 이름을 성적이 낮은 순서대로 출력 성적이 동일한 학생의 순서는 자유롭게 출력 My Solution # # SOLUTION def solution(scores): sorted_list = [[] for _ in range(101)] for n, s in scores: sorted_list[s].</description></item><item><title/><link>https://yera10.github.io/docs/mystudy/algorithm-note/part2/6_%EC%A0%95%EB%A0%AC/%EC%9C%84%EC%97%90%EC%84%9C%EC%95%84%EB%9E%98%EB%A1%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/mystudy/algorithm-note/part2/6_%EC%A0%95%EB%A0%AC/%EC%9C%84%EC%97%90%EC%84%9C%EC%95%84%EB%9E%98%EB%A1%9C/</guid><description>위에서 아래로 # INPUT # 첫째줄 - 수열에 속해있는 수의 개수 N, (1 &amp;lt;= N &amp;lt;= 500) 둘째줄부터 N개의 수 입력됨 (범위 1~100,000의 자연수) OUTPUT # 입력으로 주어진 수열이 내림차순으로 정렬된 결과를 공백으로 구분하여 출력 Example # INPUT OUTPUT 3152712 27 15 12 My Solution # # SOLUTION def solution(arr): cnt_list = [0 for _ in range(100001)] for v in arr: cnt_list[v] += 1 for i in range(100000, -1, -1): for _ in range(cnt_list[i]): print(i, end=&amp;#39; &amp;#39;) # TEST N = int(input()) arr = [] for _ in range(N): arr.</description></item><item><title/><link>https://yera10.github.io/docs/mystudy/algorithm-note/part2/6_%EC%A0%95%EB%A0%AC/%EC%A0%95%EB%A0%AC%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EA%B3%84%EC%88%98%EC%A0%95%EB%A0%AC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/mystudy/algorithm-note/part2/6_%EC%A0%95%EB%A0%AC/%EC%A0%95%EB%A0%AC%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EA%B3%84%EC%88%98%EC%A0%95%EB%A0%AC/</guid><description>계수 정렬 # 특정한 조건이 부합할 때만 사용할 수 있지만, 매우 빠른 정렬 알고리즘 데이터가 모두 양의 정수이며, 데이터의 개수가 N, 최댓값이 K일 때, 계수 정렬은 최악의 경우에도 수행시간 $O(N+K)$을 보장함 매우 빠르게 동작하며, 매우 간단한 원리 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때만 사용 가능 실수형 데이터로 주어질 때 사용하기 어려움 일반적으로는 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000을 넘지 않을 때 효과적 데이터의 범위가 너무 크면 계수정렬을 사용할 수 없음.</description></item><item><title/><link>https://yera10.github.io/docs/mystudy/algorithm-note/part2/6_%EC%A0%95%EB%A0%AC/%EC%A0%95%EB%A0%AC%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%82%BD%EC%9E%85%EC%A0%95%EB%A0%AC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/mystudy/algorithm-note/part2/6_%EC%A0%95%EB%A0%AC/%EC%A0%95%EB%A0%AC%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%82%BD%EC%9E%85%EC%A0%95%EB%A0%AC/</guid><description>삽입정렬 # 데이터를 하나씩 확인하며, 각 데이터의 적절한 위치에 삽입하면 어떨까? 선택정렬에 비해 구현 난이도가 높은 편이지만, 실행 시간 측면에서 더 효율적인 알고리즘 특히 삽입 정렬은 필요할 때만 위치를 바꾸기 때문에 &amp;ldquo;데이터가 거의 정렬되어 있을 때&amp;rdquo; 효율적 특정한 데이터를 적절한 위치에 &amp;ldquo;삽입&amp;quot;한다는 의미 삽입정렬 방법 특정한 데이터가 적절한 위치에 들어가기 이전에 그 앞까지의 데이터는 이미 정렬되어 있다고 가정 정렬되어 있는 리스트에 적절한 위치를 찾은 뒤, 그 위치에 삽입 특정 데이터가 삽입될 위치를 선정할 때(왼쪽으로 한 칸씩 이동하며 탐색할 때), 삽입될 데이터보다 작은 데이터를 만나면, 그 위치에서 멈춤 삽입정렬 소스코드</description></item><item><title/><link>https://yera10.github.io/docs/mystudy/algorithm-note/part2/6_%EC%A0%95%EB%A0%AC/%EC%A0%95%EB%A0%AC%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%84%A0%ED%83%9D%EC%A0%95%EB%A0%AC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/mystudy/algorithm-note/part2/6_%EC%A0%95%EB%A0%AC/%EC%A0%95%EB%A0%AC%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%84%A0%ED%83%9D%EC%A0%95%EB%A0%AC/</guid><description>선택 정렬 # 매번 가장 작은 것을 선택한다는 의미의 알고리즘 가장 작은 데이터를 맨 앞에 있는 데이터와 바꾸고,
그 다음 작은 데이터를 두 번째 데이터와 바꾸고 &amp;hellip; 이런 과정을 반복 # INPUT arr = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8] # SOLUTION def select_sorting(arr): for i in range(len(arr)): min_i = i for j in range(i+1, len(arr)): if arr[j] &amp;lt; arr[min_i]: min_i = j arr[i], arr[min_i] = arr[min_i], arr[i] # OUTPUT select_sorting(arr) print(arr) 선택 정렬의 시간복잡도는 $N + (N-1) + \dots + 2$ 로 $O(N^2)$ 이다.</description></item><item><title/><link>https://yera10.github.io/docs/mystudy/algorithm-note/part2/6_%EC%A0%95%EB%A0%AC/%EC%A0%95%EB%A0%AC%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%80%B5%EC%A0%95%EB%A0%AC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/mystudy/algorithm-note/part2/6_%EC%A0%95%EB%A0%AC/%EC%A0%95%EB%A0%AC%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%80%B5%EC%A0%95%EB%A0%AC/</guid><description>퀵 정렬 # 정렬 알고리즘 중 가장 많이 사용되는 알고리즘
퀵 정렬과 비교할만큼 빠른 알고리즘으로 &amp;lsquo;병합 정렬&amp;rsquo;이 있음.
퀵 정렬과 병합 정렬은 대부분의 프로그래밍 언어에서 정렬 라이브러리의 근간이 되는 알고리즘이기도 함.
기준을 설정한 다음 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식으로 동작
퀵 정렬에서는 피벗(Pivot)이 사용된다.
큰 숫자와 작은 숫자를 교환할 때, 교환하기 위한 &amp;lsquo;기준&amp;rsquo;을 피벗이라고 표현
피벗을 어떻게 설정하고 리스트를 분할하는지에 따라 여러 가지 방식의 퀵 정렬이 있다.</description></item><item><title/><link>https://yera10.github.io/docs/mystudy/algorithm-note/part2/7_%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89/%EB%96%A1%EB%B3%B6%EC%9D%B4%EB%96%A1%EB%A7%8C%EB%93%A4%EA%B8%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/mystudy/algorithm-note/part2/7_%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89/%EB%96%A1%EB%B3%B6%EC%9D%B4%EB%96%A1%EB%A7%8C%EB%93%A4%EA%B8%B0/</guid><description>떡볶이 떡 만들기 # INPUT # 첫째줄: N, M = 떡의 개수, 요청한 떡의 길이
($1\le N \le 1,000,000, 1\le M \le 2,000,000,000$) 둘째줄: 떡의 개별 높이 떡의 개별 높이의 총합은 항상 M 이상. 높이는 1,000,000,000보다 작거나 같은 양의 정수 또는 0 OUTPUT # 적어도 M만큼 떡을 가져가기 위해 절단기에 설정할 수 있는 높이의 최댓값 Example # 문제 # 절단기에 높이 H를 설정하면, 높이가 H보다 긴 떡만 H 위의 부분이 잘림.</description></item><item><title/><link>https://yera10.github.io/docs/mystudy/algorithm-note/part2/7_%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89/%EB%B6%80%ED%92%88%EC%B0%BE%EA%B8%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/mystudy/algorithm-note/part2/7_%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89/%EB%B6%80%ED%92%88%EC%B0%BE%EA%B8%B0/</guid><description>부품 찾기 # INPUT # $N$ : 탐색할 배열의 크기 ($1 \le N \le 1,000,000$) 공백으로 구분된 N개의 정수: 탐색할 배열, $1 &amp;lt; 정수 \le 1,000,000$ $M$ : 찾으려는 숫자의 갯수 ($1 \le M \le 100,000$) 공백으로 구분된 M개의 정수: 탐색할 값, ($1 &amp;lt; N \le 1,000,000$) OUTPUT # 찾으려는 값들의 존재 여부를 yes, no로 출력 Example # Input Output 58 3 7 9 235 7 9 no yes yes My Solution # # SOLUTION def binary_search(arr, target, s, e): if e &amp;lt; s: return -1 m = (s+e)//2 if arr[m] &amp;lt; target: return binary_search(arr, target, m+1, e) elif arr[m] &amp;gt; target: return binary_search(arr, target, s, m-1) else: return arr[m] def solution(arr, targets, N): arr.</description></item><item><title/><link>https://yera10.github.io/docs/mystudy/algorithm-note/part2/7_%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89/%EC%A7%95%EA%B2%80%EB%8B%A4%EB%A6%AC%EA%B1%B4%EB%84%88%EA%B8%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/mystudy/algorithm-note/part2/7_%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89/%EC%A7%95%EA%B2%80%EB%8B%A4%EB%A6%AC%EA%B1%B4%EB%84%88%EA%B8%B0/</guid><description>프로그래머스 - 징검다리 건너기 # 문제 링크 : 링크
Input # 디딤돌에 적힌 숫자가 순서대로 담긴 배열 stones 한 번에 건너뛸 수 있는 디딤돌의 최대 칸수 k 디딤돌에는 모두 숫자가 적혀 있으며 디딤돌의 숫자는 한 번 밟을 때마다 1씩 줄어듭니다. 디딤돌의 숫자가 0이 되면 더 이상 밟을 수 없으며 이때는 그 다음 디딤돌로 한번에 여러 칸을 건너 뛸 수 있습니다. 단, 다음으로 밟을 수 있는 디딤돌이 여러 개인 경우 무조건 가장 가까운 디딤돌로만 건너뛸 수 있습니다 Output # 최대 몇 명까지 징검다리를 건널 수 있는지 return 입력과 출력 예 # stones k result [2, 4, 5, 3, 2, 1, 4, 2, 5, 1] 3 3 나의 풀이 코드 # 통과 (313.</description></item><item><title/><link>https://yera10.github.io/docs/mystudy/algorithm-note/part2/8_%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/1%EB%A1%9C%EB%A7%8C%EB%93%A4%EA%B8%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/mystudy/algorithm-note/part2/8_%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/1%EB%A1%9C%EB%A7%8C%EB%93%A4%EA%B8%B0/</guid><description>1로 만들기 # 정수 X에 대해 4가지 연산을 사용해 1을 만들려고 함. 최소한의 연산횟수를 구하기.
연산
X가 5로 나누어 떨어지면, 5로 나눈다. X가 3로 나누어 떨어지면, 3으로 나눈다. X가 2로 나누어 떨어지면, 2로 나눈다. X에서 1을 뺀다. INPUT # 첫째줄 정수 X 1 &amp;lt;= X &amp;lt;= 30,000 OUTPUT # 최소한의 연산 횟수 My Solution # 연산1이 항상 연산2보다 좋다고 할 수 없음.
(연산2가 항상 연산3보다 좋을 수 없으며, 연산3이 항상 연산4보다 좋을 수 없음.</description></item><item><title/><link>https://yera10.github.io/docs/mystudy/algorithm-note/part2/8_%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%EA%B0%9C%EB%AF%B8%EC%A0%84%EC%82%AC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/mystudy/algorithm-note/part2/8_%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%EA%B0%9C%EB%AF%B8%EC%A0%84%EC%82%AC/</guid><description>개미전사 # 메뚜기 마을의 식량창고는 일직선상에 있음. 개미전사가 메뚜기의 식량창고를 선택적으로 약탈하여 식량을 뺏을 예정
하지만, 메뚜기들은 인접한 식량창고가 털리면 바로 알아챔. 고로, 최소 한 칸 이상 떨어진 식량창고를 약탈할 수 있음. 최대한 많이 얻을 수 있는 식량은?
INPUT # 첫째줄에 식량창고의 개수 N, 3 &amp;lt;= N &amp;lt;= 100 둘째줄에 공백으로 구분된 식량창고에 저장된 식량의 개수 K 0 &amp;lt;= K &amp;lt;= 1000 OUTPUT # 개미전사가 얻을 수 있는 식량의 최댓값 Example # 입력 출력 41 3 1 5 8 My Solution # def solution(N, arr): dp_arr = arr[:2] + [0]*(N-2) for i in range(2, N): dp_arr[i] = max(dp_arr[i-1], dp_arr[i-2] + arr[i]) return dp_arr[-1] # INPUT N = int(input()) arr = list(map(int, input().</description></item><item><title/><link>https://yera10.github.io/docs/mystudy/algorithm-note/part2/8_%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%EB%B0%94%EB%8B%A5%EA%B3%B5%EC%82%AC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/mystudy/algorithm-note/part2/8_%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%EB%B0%94%EB%8B%A5%EA%B3%B5%EC%82%AC/</guid><description> 바닥공사 # 세로 x 가로가 2 x N인 바닥에 1x2 2x1 2x2 인 타일을 덮는 경우의 수 구하기
INPUT # 가로길이 N 1 &amp;lt;= N &amp;lt;= 1,000 OUTPUT # 바닥을 채우는 방법의 수를 796,796으로 나눈 나머지 구하기 My Solution # 세로가 무조건 2니까 2x2 공간을 덮는 경우의 수는 3가지 하지만 무조건 2칸으로 다 나눌 수는 없다! 개미전사 문제처럼 앞에서부터 한칸씩 풀면 될까? 가로가 N일때 경우의 수는 (N-1일 때 방법의 수) + (N-2일 때 방법의 수)*2 def solution(N): arr = [0]*N arr[0] = 1 arr[1] = 3 for i in range(2, N): arr[i] = (arr[i-1] + 2*arr[i-2]) % 796796 return arr[-1] # INPUT &amp;amp; OUTPUT N = int(input()) print(solution(N))</description></item><item><title/><link>https://yera10.github.io/docs/mystudy/algorithm-note/part2/8_%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8%ED%99%94%ED%8F%90%EA%B5%AC%EC%84%B1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/mystudy/algorithm-note/part2/8_%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8%ED%99%94%ED%8F%90%EA%B5%AC%EC%84%B1/</guid><description>효율적인 화폐 구성 # N가지 종류의 화폐로 최소한의 갯수를 사용해서 M원 만들기.
INPUT # 화폐의 종류 수 N 1 &amp;lt;= N &amp;lt;= 100 만들려는 목표 금액 M 1 &amp;lt;= M &amp;lt;= 10,000 OUTPUT # M원을 만들기 위한 최소한의 화폐 개수 불가능할 때는 -1 My Solution # def solution(M, coins): d = [0] + [-1]*10000 for i in range(1, M+1): dmin = 10001 for c in coins: if i-c &amp;gt;= 0 and d[i-c] &amp;gt;= 0: dmin = min(dmin, d[i-c]) dmin = dmin + 1 if dmin!</description></item><item><title/><link>https://yera10.github.io/docs/mystudy/algorithm-note/part3/11_greedy/%EA%B3%B1%ED%95%98%EA%B8%B0-%ED%98%B9%EC%9D%80-%EB%8D%94%ED%95%98%EA%B8%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/mystudy/algorithm-note/part3/11_greedy/%EA%B3%B1%ED%95%98%EA%B8%B0-%ED%98%B9%EC%9D%80-%EB%8D%94%ED%95%98%EA%B8%B0/</guid><description>곱하기 혹은 더하기 # Input # S : 첫째 줄에 주어지는 여러 개의 숫자로 구성된 문자열 (1 &amp;lt;= S의 길이 &amp;lt;= 20) Output # 만들어질 수 있는 가장 큰 수 Rule # 왼쪽부터 오른쪽으로 하나씩 모든 숫자 사이에 &amp;ldquo;x&amp;rdquo; 혹은 &amp;ldquo;+&amp;rdquo; 연산자를 넣어 만들어질 수 있는 가장 큰 수 구하기 연산 순서는 &amp;ldquo;x&amp;rdquo;, &amp;ldquo;+&amp;rdquo; 상관 없이 무조건 왼쪽부터 순서대로 Example # 입력 출력 02984 576 567 210 My Solution # def solution(S): S = list(S) res = int(S.</description></item><item><title/><link>https://yera10.github.io/docs/mystudy/algorithm-note/part3/11_greedy/%EB%A7%8C%EB%93%A4%EC%88%98%EC%97%86%EB%8A%94%EA%B8%88%EC%95%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/mystudy/algorithm-note/part3/11_greedy/%EB%A7%8C%EB%93%A4%EC%88%98%EC%97%86%EB%8A%94%EA%B8%88%EC%95%A1/</guid><description>만들 수 없는 금액 # Input # 첫째 줄: 에 입력되는 동전의 개수 N (1 &amp;lt;= N &amp;lt;= 1,000) 둘째 줄: 각 동전의 화폐 단위를 나타나는 N개의 자연수, Output # 첫째 줄에 주어진 동전들로 만들 수 없는 양의 정수 금액 중 최솟값 Rule # N개의 동전을 이용하여 만들 수 없는 양의 정수 금액 중 최솟값을 구하는 프로그램 작성 Example # 입력 출력 5 3 2 1 1 9 8 My Solution # import heapq def solution(coins): coins.</description></item><item><title/><link>https://yera10.github.io/docs/mystudy/algorithm-note/part3/11_greedy/%EB%AA%A8%ED%97%98%EA%B0%80%EA%B8%B8%EB%93%9C/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/mystudy/algorithm-note/part3/11_greedy/%EB%AA%A8%ED%97%98%EA%B0%80%EA%B8%B8%EB%93%9C/</guid><description> 모험가 길드 # Input # N : 첫째 줄에 주어지는 모험가의 수 1 &amp;lt;= N &amp;lt;= 100,000 각 모험가의 공포도 : 둘째 줄에 주어지는 N이하의 자연수 값들, 공백으로 구분됨 Output # 여행을 떠날 수 있는 그룹 수의 최대값 Rule # 공포도가 X인 모험가는 반드시 X명 이상으로 구성한 모험가 그룹에 참여해야 여행을 떠날 수 있음 최대로 만들 수 있는 모험감의 그룹? Example # 입력 출력 5 2 3 1 2 2 2</description></item><item><title/><link>https://yera10.github.io/docs/mystudy/algorithm-note/part3/11_greedy/%EB%B3%BC%EB%A7%81%EA%B3%B5%EA%B3%A0%EB%A5%B4%EA%B8%B0/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/mystudy/algorithm-note/part3/11_greedy/%EB%B3%BC%EB%A7%81%EA%B3%B5%EA%B3%A0%EB%A5%B4%EA%B8%B0/</guid><description>볼링공 고르기 # Input # 첫째줄 N, M : 볼링공의 갯수 N, 공의 최대 무게 M 둘째줄 각 볼링공의 무게 K : 순서대로 자연수 1 &amp;lt;= N &amp;lt;= 1,000, 1 &amp;lt;= M &amp;lt;=10 1 &amp;lt;= K &amp;lt;= M Output # 두 사람이 볼링공을 고르는 경우의 수 출력 Rule # 두 사람이 서로 다른 무게의 볼링공을 고르도록 한다. Example # 입력 출력 5 3 1 3 2 3 2 8 8 5 1 5 4 3 2 4 5 2 25 My Solution # from collections import Counter def solution(N, data): cnt = Counter(data) res = N * (N-1) for k,v in cnt.</description></item><item><title/><link>https://yera10.github.io/docs/mystudy/deep-learning-study/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/mystudy/deep-learning-study/readme/</guid><description>DL # Deep Learning 공부 기록 노트</description></item><item><title/><link>https://yera10.github.io/docs/mystudy/hidden/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/mystudy/hidden/</guid><description>This page is hidden in menu # Quondam non pater est dignior ille Eurotas # Latent te facies # Lorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.
Pater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor Cum honorum Latona # O fallor in sustinui iussorum equidem.</description></item><item><title>clone 관련</title><link>https://yera10.github.io/docs/memo/commands/git/clone/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/memo/commands/git/clone/</guid><description> 클론 # git clone {REPO_URL} {DIR_생략가능}</description></item><item><title>commit 취소</title><link>https://yera10.github.io/docs/memo/commands/git/cancel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/memo/commands/git/cancel/</guid><description> commit 취소 # # 꺽쇠 수만큼 전으로 돌아감 git reset HEAD^ git reset HEAD^^ # 숫자만큼 전으로 돌아감 git reset HEAD~1 git reset HEAD~2 commit 취소 - push 했을 때 # git reset HEAD^ # 원하는 시점으로 되돌리기 git reflog git reset {commit id} # 강제 푸시 git push origin {branch name} -f</description></item><item><title>credential 관련</title><link>https://yera10.github.io/docs/memo/commands/git/credential/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/memo/commands/git/credential/</guid><description> Credential 정보를 반영구 저장 # git config credential.helper store</description></item><item><title>GPU 관련</title><link>https://yera10.github.io/docs/memo/commands/linux/gpu/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/memo/commands/linux/gpu/</guid><description> GPU 스펙 확인 # nvidia-smi 사용용량 확인 # nvidia-smi</description></item><item><title>Poetry 시작하기</title><link>https://yera10.github.io/docs/memo/commands/poetry/poetry_start/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/memo/commands/poetry/poetry_start/</guid><description>poetry 설치 (Windows) # pip으로 설치
pip install --user poetry powershell에서 아래 명령어로 설치
(Invoke-WebRequest -Uri https://install.python-poetry.org -UseBasicParsing).Content | py - poetry 환경변수 등록 # windows
C:\Users\SEJONG\AppData\Roaming\Python\Scripts\ 또는 C:\Users\SEJONG\AppData\Roaming\Python\Python311\Scripts\ 또는 C:\Users\SEJONG\AppData\Roaming\pypoetry\venv\Scripts\ 에 poetry 가 있는지 확인 poetry가 있는 주소를 환경변수에 등록 poetry 시작 # poetry init 각 입력사항에 맞게 입력하면, pyproject.toml 생성됨
poetry config # # poetry 설정값 확인 poetry config --list # 프로젝트 폴더 내에 가상환경을 저장 poetry config virtualenvs.</description></item><item><title>python 실행파일 인자값 받기</title><link>https://yera10.github.io/docs/memo/commands/etc/python-parameter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/memo/commands/etc/python-parameter/</guid><description>python 실행파일 인자값 받기 # 1. sys.argv # test.py 가 아래와 같은 파일이고, import sys print(sys.argv) 아래 명령어를 실행하면, $ python test.py abc hello name 출력은 아래와 같다. [&amp;#39;test.py&amp;#39;, &amp;#39;abc&amp;#39;, &amp;#39;hello&amp;#39;, &amp;#39;name&amp;#39;] sys.argv는 리스트이고, [0]은 무조건 실행파일명, 그 다움 순서대로 입력받은 인자값이 리스트에 들어감 2. configparser # 아래와 같이 Section, Key, Value 값의 형태로 설정된 설정 파일을 사용 config file (확장자 .cfg) [SectionOne] # Section - 대괄호 Status: Single # 속성 - Key : Value Name: Derek Value: Yes Age: 30 [SectionTwo] FavoriteColor = Green # :(콜론)을 써도 되고, =(equal)을 써도 된다.</description></item><item><title>python3 venv 사용법</title><link>https://yera10.github.io/docs/memo/commands/etc/python-venv/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/memo/commands/etc/python-venv/</guid><description>venv # python2에서는 써드파티 라이브러리인 virtualenv 가상환경 라이브러리를 사용
python3에서는 기본적으로 제공되는 venv 가상환경 라이브러리를 사용
가상환경 생성 # python -m venv {가상환경이름} 가상환경 활성화 # {가상환경이름}\Scripts\activate.bat 가상환경 삭제 # 가상환경 이름의 폴더를 휴지통으로 이동 (삭제)</description></item><item><title>python3 서버열기</title><link>https://yera10.github.io/docs/memo/commands/etc/python-server/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/memo/commands/etc/python-server/</guid><description> python 으로 http 서버 열기 # $ python3 -m http.server &amp;lt;포트번호 ex.8000&amp;gt;</description></item><item><title>Ubuntu Screen 명령어</title><link>https://yera10.github.io/docs/memo/commands/linux/screen/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/memo/commands/linux/screen/</guid><description> screen tool 설치 # sudo apt-get install screen screen 생성 # screen -S &amp;lt;생성할 스크린 이름&amp;gt; screen 나가기 # ctrl + a + d (단축키) screen 리스트 확인 # screen -ls 생성된 screen에 재접속 # screen -R &amp;lt;접속할 스크린 이름&amp;gt;</description></item><item><title>VSCode 단축키</title><link>https://yera10.github.io/docs/memo/commands/etc/vscode_shortcuts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/memo/commands/etc/vscode_shortcuts/</guid><description> 내가 자주 쓰는 VSCode 단축키 # 설명 단축키 코드 전체 접기 Ctrl + k + 0 코드 전체 펼치기 Ctrl + k + j</description></item><item><title>가상환경 관련</title><link>https://yera10.github.io/docs/memo/commands/conda/virtual_env/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/memo/commands/conda/virtual_env/</guid><description> 가상환경 생성 # conda create -n &amp;lt;가상환경명&amp;gt; conda create -n &amp;lt;가상환경명&amp;gt; python=3.7 conda create -n &amp;lt;가상환경명&amp;gt; --clone &amp;lt;가상환경명&amp;gt; 가상환경 목록 # conda env list conda info envs 가상환경에 jupyter kernel 연결 # python -m ipykernel install --user --name &amp;lt;가상환경명&amp;gt; --display-name &amp;lt;커널명&amp;gt; 가상환경 삭제 # conda remove --name {가상환경명} --all 가상환경 활성화 # conda activate {가상환경명} 가상환경 비활성화 # conda deactivate</description></item><item><title>가상환경 관련</title><link>https://yera10.github.io/docs/memo/commands/poetry/virtual_env/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/memo/commands/poetry/virtual_env/</guid><description> 가상환경 비활성화 # deactivate exit poetry 가상환경 확인 # poetry env list 프로젝트 폴더 내에 가상환경을 저장 # poetry config virtualenvs.in-project true 가상환경 모두 삭제 # poetry env remove --all poetry 로 가상환경(virtualenv)을 관리 # poetry env use {파이썬경로}</description></item><item><title>간단한 히스토그램 python</title><link>https://yera10.github.io/docs/memo/freq-used-code/histogram/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/memo/freq-used-code/histogram/</guid><description>import matplotlib.pyplot as plt plt.hist(data, bins=bin_num) import matplotlib.pyplot as plt import numpy as np cnts, bins = np.histogram(data, bin_num) plt.his(data, bins)</description></item><item><title>경고 무시 python</title><link>https://yera10.github.io/docs/memo/freq-used-code/warnings/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/memo/freq-used-code/warnings/</guid><description> python 경고 무시하기 # import warnings warnings.filterwarnings(action=&amp;#39;ignore&amp;#39;)</description></item><item><title>내보내기 (requirements.txt)</title><link>https://yera10.github.io/docs/memo/commands/poetry/export/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/memo/commands/poetry/export/</guid><description> poetry 환경 requirements.txt로 내보내기 # # 기본 활용 방식 poetry export -f requirements.txt --output requirements.txt # 해시 정보 없이 export 하기 poetry export -f requirements.txt --output requirements.txt --without-hashes</description></item><item><title>백그라운드 관련</title><link>https://yera10.github.io/docs/memo/commands/linux/background/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/memo/commands/linux/background/</guid><description> 백그라운드 프로세스 목록 # jobs 출력
[job 번호]job기호 job상태 백그라운드 프로세스 종료 # kill %&amp;lt;job 번호&amp;gt;</description></item><item><title>서브모듈 관련</title><link>https://yera10.github.io/docs/memo/commands/git/submodule/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/memo/commands/git/submodule/</guid><description>ref - git doc
서브모듈 추가 # git submodule add {저장소 URL} 서브모듈 끊기 # # 1. 모듈 deinit git submodule deinit -f {모듈명} # 2. .git/modules 에서 폴더 삭제 rm -rf .git/modules/{모듈명} # 3. git에서 해당 폴더를 제거 git rm -f {모듈명} 서브모듈까지 모두 clone # git clone --recursive {저장소 URL} 또는
git clone {저장소 URL} git submodule update --init --recursive 서브모듈까지 모두 업데이트(pull) # # 모든 서브모듈에 대해 동일한 명령어를 수행하고 싶을 때 git submodule foreach [명령어] # 모든 서브모듈에 대해 git pull git submodule foreach git pull origin master 또는</description></item><item><title>소수 관련 코드</title><link>https://yera10.github.io/docs/mystudy/algorithm-note/prime_number_code/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/mystudy/algorithm-note/prime_number_code/</guid><description> 소수 여부 확인 # def is_prime(n): if n==1: return False for d in range(2, int(n**0.5)+1): if n%d==0: return False return True 약수 구하기 # def solution(n): answer = set() for d in range(1, int(n**0.5)+1): if n%d==0: answer.add(d) answer.add(n//d) return sorted(list(answer)) 최대공약수와 최소공배수 # math 사용 import math math.gcd(a, b) # 최대공약수 math.lcm(a, b) # 최소공배수 직접 구현 # 자연수 a, b의 최대공약수 구하는 함수 def gcd(a, b): if b==0: return a else: return gcd(b, a%b) # 자연수 a, b의 최소공배수 구하는 함수 def lcm(a, b): return a*b//gcd(a,b)</description></item><item><title>시간 측정 python</title><link>https://yera10.github.io/docs/memo/freq-used-code/time/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/memo/freq-used-code/time/</guid><description> 코드 시간 측정하기 # import time start = time.time() ### 실행코드 ### end = time.time() print(end-start) # 초단위</description></item><item><title>압축 관련</title><link>https://yera10.github.io/docs/memo/commands/linux/zip_tar_gz/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/memo/commands/linux/zip_tar_gz/</guid><description> 압축 해제 # tar -zxvf [압축파일] -C [폴더이름]</description></item><item><title>의존성 관련</title><link>https://yera10.github.io/docs/memo/commands/poetry/dependency/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/memo/commands/poetry/dependency/</guid><description>poetry 그룹에 의존성 추가 # poetry add {패키지} --group {그룹명} poetry 버전 지정하여 의존성 추가 # poetry add &amp;#34;&amp;lt;패키지&amp;gt;&amp;lt;버전표기&amp;gt;&amp;#34; # 예 poetry add &amp;#34;selenium^4.10.0&amp;#34; # 가장 최신 버전 설치할 때 poetry add {패키지}@latest 버전 표기법 # ^1.2.3 : &amp;gt;=1.2.3 &amp;lt;2.0.0 ^1.2 : &amp;gt;=1.2.0 &amp;lt;2.0.0 ~2.0.5 : &amp;gt;=2.0.5, &amp;lt;2.1.0 &amp;gt;=2.0.5 ==2.0.5 설치된 모든 패키지 확인 # poetry show # 특정패키지를 지정 poetry show {패키지} # 의존성 트리 poetry show --tree 의존성 꼬였을 때 # 가상환경 삭제 poetry env remove --all pyproject.</description></item><item><title>자료구조 기초</title><link>https://yera10.github.io/docs/mystudy/algorithm-note/part2/5_dfs_bfs/datastructure/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/mystudy/algorithm-note/part2/5_dfs_bfs/datastructure/</guid><description>자료구조 기초 # 탐색 # 많은 양의 데이터 중 원하는 데이터를 찾는 과정 그래프, 트리 등의 자료구조 안에서 탐색하는 문제를 자주 다룸. 대표적인 탐색 알고리즘으로 DFS, BFS를 꼽을 수 있다. 자료구조 # 데이터를 표현하고 관리하고 처리하기 위한 구조 스택과 큐는 자료구조의 기초개념으로 &amp;ldquo;삽입&amp;rdquo;, &amp;ldquo;삭제&amp;rdquo; 의 두 핵심 함수로 구성됨 스택 : 선입후출 / 후입선출 큐 : 선입선출 구조 재귀함수 컴퓨터 내부에서 재귀함수의 수행은 스택 자료구조를 이용 (가장 마지막에 호출한 함수가 먼저 수행을 끝내야 그 앞의 함수 호출이 종료되기 때문에) 스택 자료구조를 활용해야 하는 상당 수 알고리즘은 재귀 함수를 이용해 간편하게 구현될 수 있다.</description></item><item><title>초기설정 관련</title><link>https://yera10.github.io/docs/memo/commands/git/initial_setup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/memo/commands/git/initial_setup/</guid><description>모든 설정값 확인 # git config --list 특정값 확인
git config user.name 모든 설정값과 해당 위치 확인 # git config --list --show-origin 사용자 이름 및 이메일 설정 # git config --global user.name &amp;#34;&amp;lt;사용자ID&amp;gt;&amp;#34; git config --global user.email {이메일} * global 옵션을 전달할 경우 한번만 수행해도 된다.
설정값 지우기 # git config --unset user.name git config --unset user.email git config --unset --global user.name git config --unset --global user.email * global로 설정한 경우, global로 지워야 한다.</description></item><item><title>터미널 테마</title><link>https://yera10.github.io/docs/memo/commands/etc/terminal_theme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/memo/commands/etc/terminal_theme/</guid><description>터미널 테마 바꾸기 # https://terminalsplash.com/</description></item><item><title>파일 생성/이동/복사/삭제</title><link>https://yera10.github.io/docs/memo/commands/linux/file_dir/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/memo/commands/linux/file_dir/</guid><description>파일 이동 # mv &amp;lt;이동전 파일 path&amp;gt; &amp;lt;이동후 파일 path&amp;gt; mv /home/index.html /home/test/index.html 파일 복사 # cp &amp;lt;복사전 파일 path&amp;gt; &amp;lt;복사후 파일 path&amp;gt; cp /home/index.html /home/test/index.html 디렉토리 이동 # mv &amp;lt;원본폴더&amp;gt; &amp;lt;목적지폴더&amp;gt; 디렉토리 복사 # cp -r &amp;lt;복사전 dir_path&amp;gt; &amp;lt;복사될 상위 dir_path&amp;gt; cp -r /home/index /home/test # home/test/index 폴더가 생성됨 디렉토리 생성 # mkdir &amp;lt;디렉토리명&amp;gt; 옵션 -m : 폴더 권한 설정 파일 삭제 # rm &amp;lt;파일명&amp;gt; 디렉토리 삭제 # rm -r &amp;lt;파일명&amp;gt; -r 옵션: recursive, 폴더를 지우거나 폴더 안의 파일을 전부 지울 때 -f 옵션 : 진짜로 지울거냐는 확인 없이 강제로 지움.</description></item><item><title>파일 압축 python</title><link>https://yera10.github.io/docs/memo/freq-used-code/file_zip/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/memo/freq-used-code/file_zip/</guid><description> 파일 압축 # import zipfile zf = zipfile.ZipFile(&amp;#39;.//foldername//filename.zip&amp;#39;, &amp;#39;w&amp;#39;) zf.write(&amp;#39;filepath&amp;#39;) # compress_type=zipfile.ZIP_DEFLATED zf.close() 압축 해제 후 DataFrame으로 변환 # import zipfile from pyarrow import csv zf = zipfile.ZipFile(&amp;#39;..//foldername//filename.zip&amp;#39;, &amp;#39;r&amp;#39;) df = csv.read_csv(zf.open(&amp;#39;content_hit-2021.03.csv&amp;#39;)).to_pandas()</description></item><item><title>파일 읽기 python</title><link>https://yera10.github.io/docs/memo/freq-used-code/file_open/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://yera10.github.io/docs/memo/freq-used-code/file_open/</guid><description>내장함수 open으로 파일 읽기 (txt, csv, json) # readline readline( ) 함수 사용 # 제너레이터처럼 한줄씩 꺼내서 str 타입으로 읽어들인다.
(txt, csv, json 파일도 가능)
f = open(&amp;#34;d:\\data\\emp3.csv&amp;#34;, &amp;#34;r&amp;#34;) file = [] while True: line = f.readline() # readline: 한줄씩 읽어들임 if not line: break file.append(line) # readline: 한줄을 문자열로 반환 f.close() print(file) # file : [ str, str, ..., str ] 의 형태 readlines readlines( ) 함수 사용 # readline( ) 함수와는 다르게 list 타입으로 반환한다.</description></item></channel></rss>