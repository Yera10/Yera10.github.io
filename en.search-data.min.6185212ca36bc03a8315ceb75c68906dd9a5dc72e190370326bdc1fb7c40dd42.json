[{"id":0,"href":"/docs/mystudy/","title":"My Study","section":"Docs","content":" Introduction # Ferre hinnitibus erat accipitrem dixi Troiae tollens # Lorem markdownum, a quoque nutu est quodcumque mandasset veluti. Passim inportuna totidemque nympha fert; repetens pendent, poenarum guttura sed vacet non, mortali undas. Omnis pharetramque gramen portentificisque membris servatum novabis fallit de nubibus atque silvas mihi. Dixit repetitaque Quid; verrit longa; sententia mandat quascumque nescio solebat litore; noctes. Hostem haerentem circuit plenaque tamen.\nPedum ne indigenae finire invergens carpebat Velit posses summoque De fumos illa foret Est simul fameque tauri qua ad # Locum nullus nisi vomentes. Ab Persea sermone vela, miratur aratro; eandem Argolicas gener.\nMe sol # Nec dis certa fuit socer, Nonacria dies manet tacitaque sibi? Sucis est iactata Castrumque iudex, et iactato quoque terraeque es tandem et maternos vittis. Lumina litus bene poenamque animos callem ne tuas in leones illam dea cadunt genus, et pleno nunc in quod. Anumque crescentesque sanguinis progenies nuribus rustica tinguet. Pater omnes liquido creditis noctem.\nif (mirrored(icmp_dvd_pim, 3, smbMirroredHard) != lion(clickImportQueue, viralItunesBalancing, bankruptcy_file_pptp)) { file += ip_cybercrime_suffix; } if (runtimeSmartRom == netMarketingWord) { virusBalancingWin *= scriptPromptBespoke + raster(post_drive, windowsSli); cd = address_hertz_trojan; soap_ccd.pcbServerGigahertz(asp_hardware_isa, offlinePeopleware, nui); } else { megabyte.api = modem_flowchart - web + syntaxHalftoneAddress; } if (3 \u0026lt; mebibyteNetworkAnimated) { pharming_regular_error *= jsp_ribbon + algorithm * recycleMediaKindle( dvrSyntax, cdma); adf_sla *= hoverCropDrive; templateNtfs = -1 - vertical; } else { expressionCompressionVariable.bootMulti = white_eup_javascript( table_suffix); guidPpiPram.tracerouteLinux += rtfTerabyteQuicktime(1, managementRosetta(webcamActivex), 740874); } var virusTweetSsl = nullGigo; Trepident sitimque # Sentiet et ferali errorem fessam, coercet superbus, Ascaniumque in pennis mediis; dolor? Vidit imi Aeacon perfida propositos adde, tua Somni Fluctibus errante lustrat non.\nTamen inde, vos videt e flammis Scythica parantem rupisque pectora umbras. Haec ficta canistris repercusso simul ego aris Dixit! Esse Fama trepidare hunc crescendo vigor ululasse vertice exspatiantur celer tepidique petita aversata oculis iussa est me ferro.\n"},{"id":1,"href":"/docs/mystudy/hugo-blog/1_%EC%84%A4%EC%B9%98/","title":"셋팅 및 시작","section":"Hugo로 github 블로그 만들기","content":" Intro # Ref # https://github.com/Integerous/Integerous.github.io\nhttps://ialy1595.github.io/post/blog-construct-1/\nHow to # 1. Hugo 설치 # hugo 공식깃헙에서 다운로드\n윈도우를 사용하고, 추가 기능이 필요할지 몰라 extended 버전인 hugo_extended_0.121.0_windows-amd64을 받았다. C:\\Hugo\\bin 디렉토리 생성해서 다운받은 압축파일 해제 환경변수에 Hugo 영구적으로 추가 $ setx PATH=%PATH%C:\\Hugo\\bin; hugo 실행 확인\nhugo version 또는 hugo help 명령어 2. Gihub 레포 셋팅 # Blog 저장소 Private으로 생성 (저장소명 다르게해도 됨) \u0026lt;USERNAME\u0026gt;.github.io 저장소 생성 Blog 레포를 로컬에 clone한다. git clone https://github.com/\u0026lt;USERNAME\u0026gt;/Blog.git \u0026lt;USERNAME\u0026gt;.github.io를 Blog의 서브모듈로 등록 (public 폴더로) git submodule add -b master https://github.com/\u0026lt;USERNAME\u0026gt;/Blog.git public 3. 테마 설정 # https://themes.gohugo.io/에서 테마 선택 해당 테마의 github 주소로 가서 fork 로컬에 Blog/theme 폴더 생성 fork한 저장소를 Blog/theme에 submodule로 추가 cd themes git submodule add thttps://github.com/alex-shpak/hugo-book.git config.toml 파일 설정\nconfig 설정 방법은 테마마다 다르므로 테마의 github레포나 데모에 설명되어 있음. 4. 컨텐츠 생성 및 업로드 # hugo new post/test.md 명령을 하면, content\\post\\test.md 파일이 생성된다.\n꼭 명령어를 사용하지 않아도 그냥 content 폴더 안에 markdown 파일을 작성해도 된다. hugo server -D명령으로 웹서버를 실행시켜 확인한다.\nhttp://localhost:1313/ 에서 확인 가능 hugo --minify 명령어로 빌드해준다. public 폴더를 push 하면 내 블로그\u0026lt;user-id.github.io\u0026gt;에 업데이트 되어있음.\ncd public\ngit add .\ngit commit -m \u0026quot;커밋메세지\u0026quot;\ngit push "},{"id":2,"href":"/docs/memo/","title":"메모장","section":"Docs","content":" 자주 쓰는 명령어들 Git 관련 # commit 취소 credentail 관련 clone 관련 최초 설정 관련 Linux # 파일 생성/이동/복사/삭제 백그라운드 관련 명령어 Ubuntu Screen 명령어 GPU 관련 압축해제 conda # 가상환경 관련 Poetry # Poetry 시작하기 가상환경 관련 의존성 관련 내보내기(requirements.txt) 기타 # python3의 venv 사용법 python3 서버열기 python의 인자값 받기 Docker 명령어 VSCode 단축키 터미널 테마 자주 쓰는 코드들 간단한 히스토그램 python import matplotlib.pyplot as plt plt.hist(data, bins=bin_num) import matplotlib.pyplot as plt import numpy as np cnts, bins = np.histogram(data, bin_num) plt.his(data, bins) 경고 무시 python python 경고 무시하기 # import warnings warnings.filterwarnings(action=\u0026#39;ignore\u0026#39;) 시간 측정 python 코드 시간 측정하기 # import time start = time.time() ### 실행코드 ### end = time.time() print(end-start) # 초단위 파일 압축 python 파일 압축 # import zipfile zf = zipfile.ZipFile(\u0026#39;.//foldername//filename.zip\u0026#39;, \u0026#39;w\u0026#39;) zf.write(\u0026#39;filepath\u0026#39;) # compress_type=zipfile. "},{"id":3,"href":"/docs/mystudy/hugo-blog/2_%EC%BB%A8%ED%85%90%EC%B8%A0%EC%97%B0%EA%B2%B0/","title":"컨텐츠 연결","section":"Hugo로 github 블로그 만들기","content":" git 서브모듈 사용하여 컨텐츠 연결 # 나는 기존에 깃헙레포를 노트처럼 사용하면서 공부한 내용들을 적어두고 있었다 그래서 그 레포를 블로그에 연결하고자 submodule을 사용했다.\n1. 컨텐츠 디렉토리로 이동 # cd content/docs 2. 저장소 submodule로 추가 # git submodule add {저장소의 URL} 3. 변경내용 add, commit, push # cd Blog/ git add . git commit -m \u0026#34;{커밋메시지}\u0026#34; git push "},{"id":4,"href":"/docs/mystudy/hugo-blog/3_%EC%9E%90%EB%8F%99%EC%97%85%EB%A1%9C%EB%93%9C/","title":"자동 업로드","section":"Hugo로 github 블로그 만들기","content":" Github Action을 사용하여 컨텐츠 업로드 자동화하기 # ref # 코드인용\naction 공부\nhttps://somaz.tistory.com/213#google_vignette\nhttps://fe-developers.kakaoent.com/2022/220106-github-actions/\nhttps://velog.io/@adam2/Github-Action-%EC%A3%BC%EC%9A%94-%EB%AC%B8%EB%B2%95\nhttps://kotlinworld.com/400\n1. 토큰 발급 # https://github.com 에서 우측 상단 프로필 클릭 Settings 클릭 좌측 바 하단의 Developer Settings 클릭 Personal access tockens 클릭 Generate new token 클릭 블로그 관련 모든 레포에 대한 권한을 부여한 토큰 생성 토큰 복사 2. Secret 등록 # github에서 Blog 저장소 접속 상단 바에서 Settings 클릭 좌측 네비게이션 바에서 Secrets and variables \u0026gt; Actions 클릭 New repository secret 클릭 NAME은 TOKEN으로 Secret에는 복사한 토큰을 붙여넣기 하여 등록 서브모듈 저장소들에도 위와 같은 방법으로 Secret 등록 2. 서브모듈에 Action 등록 # 아래 파일을 서브모듈인 저장소에 .github/workflows/notify.yml로 저장한 뒤, 원격저장소에 push한다. name: \u0026#34;Submodule Notify Parent\u0026#34; on: # main브랜치에 push발생했을때 실행됨 push: branches: - main # 또는 수동으로 실행 가능 workflow_dispatch: jobs: notify: # job id name: \u0026#34;Submodule Notify Parent\u0026#34; runs-on: ubuntu-latest # 가상환경 인스턴스 defaults: run: shell: bash steps: - name: Github REST API Call # step의 이름 env: CI_TOKEN: ${{secrets.TOKEN}} USER_NAME: 사용자명 PARENT_REPO: 상위저장소 이름 PARENT_BRANCH: main # 상위저장소의 브랜치명 WORKFLOW_ID: submodule-sync.yml run: | curl -fL --retry 3 -X POST -H \u0026#34;Accept: application/vnd.github.v3+json\u0026#34; -H \u0026#34;Authorization: token ${{ env.CI_TOKEN }}\u0026#34; https://api.github.com/repos/${{ env.USER_NAME }}/${{ env.PARENT_REPO }}/actions/workflows/${{ env.WORKFLOW_ID }}/dispatches -d \u0026#39;{\u0026#34;ref\u0026#34;:\u0026#34;${{ env.PARENT_BRANCH }}\u0026#34;}\u0026#39; 3. 슈퍼레포에 Action 등록 # 아래 파일을 블로그 저장소에 .github/workflows/submodule-sync.yml로 저장한 뒤, 원격저장소에 push한다. name: \u0026#39;Submodules Sync\u0026#39; on: workflow_dispatch: jobs: sync: name: \u0026#39;Submodules Sync\u0026#39; runs-on: ubuntu-latest defaults: run: shell: bash steps: - name: Checkout uses: actions/checkout@v2 # 저장소로부터 코드를 내려받음 with: token: ${{secrets.TOKEN}} submodules: true - name: Submodule Update run: | git pull --recurse-submodules git submodule update --remote --recursive git status -s - name: Setup hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#34;latest\u0026#34; - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: personal_token: ${{secrets.TOKEN}} external_repository: \u0026lt;사용자명\u0026gt;/사용자명.github.io publish_dir: ./public # 저장소 내에 public 저장소 위치 user_name: 사용자명 user_email: 사용자 email publish_branch: main # 배포할 저장소의 브랜치명 - name: Submodule Push run: | git config user.email \u0026#34;\u0026lt;email\u0026gt;\u0026#34; git config user.name \u0026#34;\u0026lt;name\u0026gt;\u0026#34; git submodule update --remote --recursive git status -s git commit -am \u0026#34;Automatic Deploy\u0026#34; git push "},{"id":5,"href":"/docs/memo/commands/conda/","title":"Conda","section":"자주 쓰는 명령어들","content":" 가상환경 관련 가상환경 생성 # conda create -n \u0026lt;가상환경명\u0026gt; conda create -n \u0026lt;가상환경명\u0026gt; python=3.7 conda create -n \u0026lt;가상환경명\u0026gt; --clone \u0026lt;가상환경명\u0026gt; 가상환경 목록 # conda env list conda info envs 가상환경에 jupyter kernel 연결 # python -m ipykernel install --user --name \u0026lt;가상환경명\u0026gt; --display-name \u0026lt;커널명\u0026gt; 가상환경 삭제 # conda remove --name {가상환경명} --all 가상환경 활성화 # conda activate {가상환경명} 가상환경 비활성화 # conda deactivate "},{"id":6,"href":"/docs/memo/commands/etc/","title":"Etc","section":"자주 쓰는 명령어들","content":" Docker docker 버전 확인 # docker -v docker image 검색 및 설치 # docker search ubuntu docker pull ubuntu:20.04 컨테이너 생성 및 실행 # docker run -it --name \u0026lt;이름\u0026gt; \u0026lt;Image이름\u0026gt; /bin/bash 컨테이너 목록 확인 # docker ps --all python 실행파일 인자값 받기 python 실행파일 인자값 받기 # 1. sys.argv # test.py 가 아래와 같은 파일이고, import sys print(sys.argv) 아래 명령어를 실행하면, $ python test.py abc hello name 출력은 아래와 같다. [\u0026#39;test.py\u0026#39;, \u0026#39;abc\u0026#39;, \u0026#39;hello\u0026#39;, \u0026#39;name\u0026#39;] sys.argv는 리스트이고, [0]은 무조건 실행파일명, 그 다움 순서대로 입력받은 인자값이 리스트에 들어감 2. configparser # 아래와 같이 Section, Key, Value 값의 형태로 설정된 설정 파일을 사용 config file (확장자 .cfg) [SectionOne] # Section - 대괄호 Status: Single # 속성 - Key : Value Name: Derek Value: Yes Age: 30 [SectionTwo] FavoriteColor = Green # :(콜론)을 써도 되고, =(equal)을 써도 된다. python3 venv 사용법 venv # python2에서는 써드파티 라이브러리인 virtualenv 가상환경 라이브러리를 사용 python3에서는 기본적으로 제공되는 venv 가상환경 라이브러리를 사용 가상환경 생성 # python -m venv {가상환경이름} 가상환경 활성화 # {가상환경이름}\\Scripts\\activate.bat 가상환경 삭제 # 가상환경 이름의 폴더를 휴지통으로 이동 (삭제) python3 서버열기 python 으로 http 서버 열기 # $ python3 -m http.server \u0026lt;포트번호 ex.8000\u0026gt; VSCode 단축키 내가 자주 쓰는 VSCode 단축키 # 설명 단축키 코드 전체 접기 Ctrl + k + 0 코드 전체 펼치기 Ctrl + k + j 터미널 테마 터미널 테마 바꾸기 # https://terminalsplash.com/ "},{"id":7,"href":"/docs/memo/commands/etc/docker/","title":"Docker","section":"Etc","content":" docker 버전 확인 # docker -v docker image 검색 및 설치 # docker search ubuntu docker pull ubuntu:20.04 컨테이너 생성 및 실행 # docker run -it --name \u0026lt;이름\u0026gt; \u0026lt;Image이름\u0026gt; /bin/bash 컨테이너 목록 확인 # docker ps --all "},{"id":8,"href":"/docs/memo/commands/linux/","title":"Linux","section":"자주 쓰는 명령어들","content":" GPU 관련 GPU 스펙 확인 # nvidia-smi 사용용량 확인 # nvidia-smi Ubuntu Screen 명령어 screen tool 설치 # sudo apt-get install screen screen 생성 # screen -S \u0026lt;생성할 스크린 이름\u0026gt; screen 나가기 # ctrl + a + d (단축키) screen 리스트 확인 # screen -ls 생성된 screen에 재접속 # screen -R \u0026lt;접속할 스크린 이름\u0026gt; 백그라운드 관련 백그라운드 프로세스 목록 # jobs 출력 [job 번호]job기호 job상태 백그라운드 프로세스 종료 # kill %\u0026lt;job 번호\u0026gt; 압축 관련 압축 해제 # tar -zxvf [압축파일] -C [폴더이름] 파일 생성/이동/복사/삭제 파일 이동 # mv \u0026lt;이동전 파일 path\u0026gt; \u0026lt;이동후 파일 path\u0026gt; mv /home/index.html /home/test/index.html 파일 복사 # cp \u0026lt;복사전 파일 path\u0026gt; \u0026lt;복사후 파일 path\u0026gt; cp /home/index.html /home/test/index.html 디렉토리 이동 # mv \u0026lt;원본폴더\u0026gt; \u0026lt;목적지폴더\u0026gt; 디렉토리 복사 # cp -r \u0026lt;복사전 dir_path\u0026gt; \u0026lt;복사될 상위 dir_path\u0026gt; cp -r /home/index /home/test # home/test/index 폴더가 생성됨 디렉토리 생성 # mkdir \u0026lt;디렉토리명\u0026gt; 옵션 -m : 폴더 권한 설정 파일 삭제 # rm \u0026lt;파일명\u0026gt; 디렉토리 삭제 # rm -r \u0026lt;파일명\u0026gt; -r 옵션: recursive, 폴더를 지우거나 폴더 안의 파일을 전부 지울 때 -f 옵션 : 진짜로 지울거냐는 확인 없이 강제로 지움. "},{"id":9,"href":"/docs/memo/commands/poetry/","title":"Poetry","section":"자주 쓰는 명령어들","content":" Poetry 시작하기 poetry 설치 (Windows) # pip으로 설치 pip install --user poetry powershell에서 아래 명령어로 설치 (Invoke-WebRequest -Uri https://install.python-poetry.org -UseBasicParsing).Content | py - poetry 환경변수 등록 # windows C:\\Users\\SEJONG\\AppData\\Roaming\\Python\\Scripts\\ 또는 C:\\Users\\SEJONG\\AppData\\Roaming\\Python\\Python311\\Scripts\\ 또는 C:\\Users\\SEJONG\\AppData\\Roaming\\pypoetry\\venv\\Scripts\\ 에 poetry 가 있는지 확인 poetry가 있는 주소를 환경변수에 등록 poetry 시작 # poetry init 각 입력사항에 맞게 입력하면, pyproject.toml 생성됨 poetry config # # poetry 설정값 확인 poetry config --list # 프로젝트 폴더 내에 가상환경을 저장 poetry config virtualenvs. 가상환경 관련 가상환경 비활성화 # deactivate exit poetry 가상환경 확인 # poetry env list 프로젝트 폴더 내에 가상환경을 저장 # poetry config virtualenvs.in-project true 가상환경 모두 삭제 # poetry env remove --all poetry 로 가상환경(virtualenv)을 관리 # poetry env use {파이썬경로} 내보내기 (requirements.txt) poetry 환경 requirements.txt로 내보내기 # # 기본 활용 방식 poetry export -f requirements.txt --output requirements.txt # 해시 정보 없이 export 하기 poetry export -f requirements.txt --output requirements.txt --without-hashes 의존성 관련 poetry 그룹에 의존성 추가 # poetry add {패키지} --group {그룹명} poetry 버전 지정하여 의존성 추가 # poetry add \u0026#34;\u0026lt;패키지\u0026gt;\u0026lt;버전표기\u0026gt;\u0026#34; # 예 poetry add \u0026#34;selenium^4.10.0\u0026#34; # 가장 최신 버전 설치할 때 poetry add {패키지}@latest 버전 표기법 # ^1.2.3 : \u0026gt;=1.2.3 \u0026lt;2.0.0 ^1.2 : \u0026gt;=1.2.0 \u0026lt;2.0.0 ~2.0.5 : \u0026gt;=2.0.5, \u0026lt;2.1.0 \u0026gt;=2.0.5 ==2.0.5 설치된 모든 패키지 확인 # poetry show # 특정패키지를 지정 poetry show {패키지} # 의존성 트리 poetry show --tree 의존성 꼬였을 때 # 가상환경 삭제 poetry env remove --all pyproject. "},{"id":10,"href":"/docs/memo/commands/readme/","title":"Readme","section":"자주 쓰는 명령어들","content":" Git 관련 # commit 취소\ncredentail 관련\nclone 관련\n최초 설정 관련\nLinux # 파일 생성/이동/복사/삭제\n백그라운드 관련 명령어\nUbuntu Screen 명령어\nGPU 관련\n압축해제\nconda # 가상환경 관련\nPoetry # Poetry 시작하기\n가상환경 관련\n의존성 관련\n내보내기(requirements.txt)\n기타 # python3의 venv 사용법\npython3 서버열기\npython의 인자값 받기\nDocker 명령어\nVSCode 단축키\n터미널 테마\n"},{"id":11,"href":"/docs/mystudy/algorithm-note/","title":"Algorithm Note","section":"My Study","content":" Part 2 3. 그리디 알고리즘 Greedy # 단순하지만 강력한 문제 해결 방법 현재 상황에서 지금 당장 좋은 것만 고르는 방법 현재의 선택이 나중에 미칠 영향에 대해서는 고려하지 않음 다익스트라 알고리즘은 엄밀히 말하면 Greedy 알고리즘 보통 코딩테스트에서 출제되는 Greedy 알고리즘 유형의 문제는 창의력, 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구 Greedy 알고리즘의 정당성 # greedy 알고리즘을 모든 문제에 적용할 수 있는 것은 아니다. Greedy로 정확한 답을 찾을 수 있다는 보장이 있을 때는 매우 효과적이고 직관적 4. Part 3 그리디 알고리즘 소수 관련 코드 소수 여부 확인 # def is_prime(n): if n==1: return False for d in range(2, int(n**0.5)+1): if n%d==0: return False return True 약수 구하기 # def solution(n): answer = set() for d in range(1, int(n**0.5)+1): if n%d==0: answer.add(d) answer.add(n//d) return sorted(list(answer)) 최대공약수와 최소공배수 # math 사용 import math math.gcd(a, b) # 최대공약수 math.lcm(a, b) # 최소공배수 직접 구현 # 자연수 a, b의 최대공약수 구하는 함수 def gcd(a, b): if b==0: return a else: return gcd(b, a%b) # 자연수 a, b의 최소공배수 구하는 함수 def lcm(a, b): return a*b//gcd(a,b) "},{"id":12,"href":"/docs/mystudy/algorithm-note/part2/3_%EA%B7%B8%EB%A6%AC%EB%94%94/1%EC%9D%B4%EB%90%A0%EB%95%8C%EA%B9%8C%EC%A7%80/","title":"1이될때까지","section":"3. 그리디 알고리즘","content":" 1이 될 때까지 # INPUT # 2 \u0026lt;= N \u0026lt;= 100,000 2 \u0026lt;= K \u0026lt;= 100,000 N \u0026gt;= K OUTPUT # N이 1이 될 때까지 수행해야 하는 과정의 최소 횟수 출력 Rule # 둘 중 하나의 과정을 반복적으로 수행 2번 과정은 N이 K로 나누어 떨어질 때만 선택 가능 N에서 1을 뺀다. N을 K로 나눈다. Example # 입력 출력 25 5 2 17 4 3 My Solution # 2번이 가능하면 2번을 수행하는 게 가장 빠른 방법 연상되는 이유는 더 크게 줄어들기 때문에 1번을 선택했을 때, 2번보다 빠르려면, 1번을 수행한 수가 K로 나누어 떨어질 때 =\u0026gt; 그러려면 K가 1이어야 한다? =\u0026gt; 하지만 $K\u0026gt;=2$ =\u0026gt; 불가능! 무조건 2번 먼저 수행 # INPUT n, k = map(int, input().split()) # SOLUTION def solution(n, k): res = 0 while n \u0026gt; 1: if n % k == 0: n //= k else: n -= 1 res += 1 return res # OUTPUT print(solution(n, k)) 정답코드 # n, k = map(int, input().split()) # SOLUTION def solution(n, k): res = 0 while n \u0026gt; 1: if n % k == 0: n //= k res += 1 else: res += (n % k) n -= (n % k) return res # OUTPUT print(solution(n, k)) "},{"id":13,"href":"/docs/mystudy/algorithm-note/part2/3_%EA%B7%B8%EB%A6%AC%EB%94%94/%EC%88%AB%EC%9E%90%EC%B9%B4%EB%93%9C%EA%B2%8C%EC%9E%84/","title":"숫자카드게임","section":"3. 그리디 알고리즘","content":" 숫자 카드 게임 # Input # N, M : 숫자카드들의 행, 열의 개수, 첫째줄에 주어짐 1 \u0026lt;= N, M \u0026lt;= 100 각 카드에 적힌 숫자들, 둘째줄부터 주어짐 1 \u0026lt;= 각 숫자 \u0026lt;= 10,000 Output # 게임의 룰에 맞게 선택한 카드에 적힌 숫자 Rule # 숫자카드들이 N x M 형태로 놓여있음 뽑고자 하는 카드가 포함되어 있는 행 선택 선택된 행에서 가장 작은 숫자카드를 뽑음 어떤 행을 선택해야 가장 높은 숫자의 카드를 뽑을 수 있을까? Example # 입력 출력 3 3 3 1 2 4 1 4 2 2 2 2 2 4 7 3 1 8 3 3 3 4 3 My Solution # 행의 최솟값들 중 최댓값 출력 # INPUT N, M = map(int, input().split()) arr = [] for _ in range(N): arr.append( list(map(int, input().split())) ) # SOLUTION def solution(N, M, arr): return max([min(a) for a in arr]) # OUTPUT print(solution(N, M, arr)) 정답코드 # n, m = map(int, input().split()) result = 0 for i in range(n): data = list(map(int, input().split())) min_value = min(data) result = max(result, min_value) print(result) "},{"id":14,"href":"/docs/mystudy/algorithm-note/part2/3_%EA%B7%B8%EB%A6%AC%EB%94%94/%ED%81%B0%EC%88%98%EC%9D%98%EB%B2%95%EC%B9%99/","title":"큰수의법칙","section":"3. 그리디 알고리즘","content":" 큰 수의 법칙 # Input # N : 2 $\\leq$ N $\\leq$ 1,000, 배열의 크기 M : 1 $\\leq$ M $\\leq$ 10,000, 숫자가 더해지는 횟수 K : 1 $\\leq$ K $\\leq$ 10,000, 특정 인덱스의 수가 연속해서 더해질 수 있는 횟수 array : 주어진 배열 항상 K \u0026lt;= M 큰 수의 법칙 # 배열의 숫자들을 M 번 더하여 가장 큰 수를 만드는 법칙 특정한 인덱스에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없다. Output # 큰 수의 법칙에 따른 결과 Example # N M K array result 5 8 3 2 4 5 4 6 46 5 7 2 3 4 3 4 3 28 예시1 : 6 + 6 + 6 + 5 + 6 + 6 + 6 + 5 = 46 예시2 : 4 + 4 + 4 + 4 + 4 + 4 + 4 = 28 My Solution # 최댓값과 그다음 최댓값 외에는 쓰이지 않음\n왜냐하면, 최댓값을 K번 만큼 더한 다음에 그 다음 최댓값을 한 번 더 더하면 최댓값 연속 더한 횟수가 초기화 되기 때문에 다른 수를 더하는 것보다 큰 수를 만들 수 있음. 최댓값 m1과 그 다음 최댓값 m2를 구한다. $m1 * K + m2$ 를 최대한 반복 =\u0026gt; $(m1\\times K + m2)\\times {M//(K+1)}$ $m1$ 을 더할 수 있는 만큼 더해주기 =\u0026gt; $m1 \\times {M%(K+1)}$\n(최대 K번이기 때문에 연속해서 더하는 것 가능) def solution(N, M, K, arr): m1 = max(arr) arr.remove(m1) m2 = max(arr) res = (M//(K+1)) * (K * m1 + m2) + sum(([m1] * K + [m2])[:M%(K+1)]) return res python의 max 시간 복잡도 : $O(n)$ python의 sort 시간 복잡도 : $O(n log n)$ Better Solution # def solution(N, M, K, arr): m1 = max(arr) arr.remove(m1) m2 = max(arr) res = (M//(K+1)) * (K * m1 + m2) + (M%(K+1)) * m1 return res "},{"id":15,"href":"/docs/mystudy/algorithm-note/part2/4_%EA%B5%AC%ED%98%84/%EA%B2%8C%EC%9E%84-%EA%B0%9C%EB%B0%9C/","title":"게임 개발","section":"4. 구현","content":" 게임 개발 # Input # N, M : 세로 크기, 가로 크기 (3 \u0026lt;= N,M \u0026lt;= 50) A, B, d : 게임 캐릭터가 있는 칸의 좌표 (A, B), 캐릭터가 바라보는 방향 d d 값 : 0 : 북 1 : 동 2 : 남 3 : 서 맵의 정보 : 육지인지 바다인지 N x M 으로 나타내줌 0 : 육지 1 : 바다 맵의 외곽은 항상 바다 게임 캐릭터가 처음 위치한 칸의 정보는 항상 육지 Output # 첫째 줄에 이동을 마친 후 캐릭터가 방문한 칸의 수 Rule # 현재 위치에서 현재 방향을 기준으로 반시계방향부터 차례대로 갈 곳을 정함 캐릭터의 왼쪽 방향(반시계 방향)에 가보지 않은 칸이 있다면, 왼쪽 방향으로 회전한 다음 왼쪽으로 한칸 전진. 왼쪽 방향에 가보지 않은 칸이 없다면, 왼쪽 방향으로만 회전 하고 1단계로 돌아가기 네 방향 모두 가본 칸이거나 바다로 되어 있는 칸이라면, 바라보는 방향을 유지한 채로 한 칸 뒤로 간 뒤, 1단계로 돌아가기. 뒤가 바다 방향이면 움직임을 멈추기. Example # 입력 출력 4 4 1 1 0 1 1 1 1 1 0 0 0 1 1 1 0 1 1 1 1 1 3 "},{"id":16,"href":"/docs/mystudy/algorithm-note/part2/4_%EA%B5%AC%ED%98%84/%EC%83%81%ED%95%98%EC%A2%8C%EC%9A%B0/","title":"상하좌우","section":"4. 구현","content":" 상하좌우 # Input # N : 공간의 크기, N x N 크기의 정사각형 공간 이동할 계획서 : 여행가가 N x N 공간에서 이동할 계획, (1\u0026lt;= 이동횟수 \u0026lt;=100) Output # 여행가가 최종적으로 도착할 지점의 좌표를 공백으로 구분하여 출력 이동할 때, N x N의 정사각형을 벗어나는 움직임은 무시됨 예를 들어, (1,1)에서 L 혹은 U의 움직임은 무시 Example # 입력 출력 5 R R R U D D 3 4 My Solution # def solution(N, moves): now = [1, 1] moves = moves.split() for m in moves: if m == \u0026#34;R\u0026#34;: now[1] += 1 elif m == \u0026#34;L\u0026#34;: now[1] -= 1 elif m == \u0026#34;U\u0026#34;: now[0] -= 1 else: now[0] += 1 now[0] = max(min(now[0], N), 1) now[1] = max(min(now[1], N), 1) return f\u0026#34;{now[0]} {now[1]}\u0026#34; N = int(input()) moves = input().split() print(solution(N, moves)) 문제 해설 # 일련의 명령어에 따라서 개체를 차례대로 이동시키므로 시뮬레이션 유형 문제 시뮬레이션 유형, 구현 유형, 완전 탐색 유형은 서로 유사함 # INPUT N = int(input()) x, y = 1, 1 plans = input().split() # 이동을 위한 변수 dx = [0, 0, -1, 1] dy = [-1, 1, 0, 0] move_types = [\u0026#39;L\u0026#39;, \u0026#39;R\u0026#39;, \u0026#39;U\u0026#39;, \u0026#39;D\u0026#39;] # solution for plan in plans: for i in range(len(move_types)): if plan == move_types[i]: nx = x + dx[i] ny = y + dy[i] if nx \u0026lt; 1 or ny \u0026lt; 1 or nx \u0026gt; n or ny \u0026gt; n: continue x, y = nx, ny print(x, y) "},{"id":17,"href":"/docs/mystudy/algorithm-note/part2/4_%EA%B5%AC%ED%98%84/%EC%8B%9C%EA%B0%81/","title":"시각","section":"4. 구현","content":" 시각 # Input # N : 정수, 0\u0026lt;= N \u0026lt;= 23 Output # 00시 00분 00초부터 N시 59분 59초 까지의 모든 시각 중 3이 하나라도 포함되는 모든 경우의수 출력 Example # 입력 출력 5 11475 My Solution # def solution(N): res = 0 for h in range(N+1): if \u0026#39;3\u0026#39; in str(h): res += 60*60 continue for m in range(60): if \u0026#39;3\u0026#39; in str(m): res += 60 continue for s in range(60): if \u0026#39;3\u0026#39; in str(s): res += 1 return res N = 5 print(solution(N)) 문제 해설 # 하루는 86,400초로 모든 경우는 86,400가지밖에 존재하지 않음. 시간제한 2초 안에 해결 가능 완전 탐색 유형 완전 탐색 알고리즘은 비효율적인 시간복잡도를 가져 데이터 수가 큰 경우에 동작하지 않을 수 있다. 데이터가 1,000,000개 이하일 때 적절 # H를임력받기 h = int(input()) count = 0 for i in range(h + 1): for j in range(60) : for k in range(60) : #매시각안에 \u0026#39;3\u0026#39;이 포함되어있다면카운트층가 if \u0026#39;3\u0026#39; in str(i) + str(j) + str(k): count += 1 print (count) "},{"id":18,"href":"/docs/mystudy/algorithm-note/part2/4_%EA%B5%AC%ED%98%84/%EC%99%95%EC%8B%A4%EC%9D%98%EB%82%98%EC%9D%B4%ED%8A%B8/","title":"왕실의나이트","section":"4. 구현","content":" 왕실의 나이트 # Input # 8 x 8 좌표평면에서 나이트가 현재 위치한 곳의 좌표 두문자로 구성된 문자열 Output # 나이트가 이동할 수 있는 경우의 수 Example # 입력 출력 a1 2 My Solution # moves = [(2, 1), (2, -1), (-2, 1), (-2, 1), (1, 2), (1, -2), (-1, 2), (-1, -2)] def solution(x): c, r = ord(x[0])-96, int(x[1]) nx = [1 for m in moves if (0 \u0026lt; (c+m[0]) \u0026lt; 9) and (0 \u0026lt; (r+m[1]) \u0026lt; 9)] return sum(nx) x = input() print(solution(x)) 문제 해설 # # 현재 나이트 위치 입력 input_data = input() row = int(inpu_data[1]) column = int(ord(input_data[0])) - int(ord(\u0026#39;a\u0026#39;)) + 1 # 8가지 이동 steps = [(2, 1), (2, -1), (-2, 1), (-2, 1), (1, 2), (1, -2), (-1, 2), (-1, -2)] # 이동가능 여부 확인 result = 0 for step in steps: nrow = row + step[0] ncol = col + step[1] if 1 \u0026lt;= nrow \u0026lt;= 8 and 1\u0026lt;= ncol \u0026lt;= 8: result += 1 # 출력 print(result) "},{"id":19,"href":"/docs/mystudy/algorithm-note/part2/5_dfs_bfs/%EB%AF%B8%EB%A1%9C%ED%83%88%EC%B6%9C/","title":"미로탈출","section":"5. DFS \u0026 BFS","content":" 미로탈출 # Input # 두 정수 N, M : 4 \u0026lt;= N, M \u0026lt;= 200 N개의 줄, M개의 정수로 미로정보 주어짐 공백 X 시작과 마지막은 항상 1 Output # 최소 이동 칸의 개수 Rule # N x M 크기의 직사각형 미로에 갇혀있다. 미로에 여러 마리의 괴물을 피해 탈출해야 함. 출발지점 (1,1)\n출구위치 (N, M)\n괴물이 있는 부분 : 0 \\ 괴물이 없는 부분 : 1 \\ 한번에 한칸씩 이동할 수 있음. 동빈이가 탈출하기 위해 움직여야 하는 최소 칸의 개수 구하기.\n미로는 반드시 탈출할 수 있는 형태로 제시됨\nExample # 입력 출력 5 6101010111111000001111111111111 10 My Solution # # SOLUTION from collections import deque def bfs(graph, start, N, M): queue = deque([start]) lv = deque([1]) while queue: i, j = queue.popleft() l = lv.popleft() if graph[i][j]: # 출구에 도착하면 return if i==(N-1) and j==(M-1): return l # 주변 탐색 for ni, nj in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]: if (ni \u0026gt;= 0) and (ni \u0026lt; N) and (nj \u0026gt;=0) and (nj \u0026lt; M): queue.append([ni, nj]) lv.append(l+1) graph[i][j] = 0 # INPUT N, M = map(int, input().split()) miro = [input() for _ in range(N)] # OUTPUT print(bfs(miro, [0,0], N, M)) Solutin # from collections import deque # INPUT n, m = map(int, input().split()) graph = [] for i in range(n): graph.append(list(map(int, input()))) # 이동방향 dx = [-1, 1, 0, 0] dy = [0, 0, -1, 1] # BFS def bfs(x,y): queue = deque() queue.append((x, y)) while queue: x, y = queue.popleft() for i in range(4): nx = x + dx[i] ny = y + dy[i] if nx \u0026lt; 0 or ny \u0026lt; 0 or nx \u0026gt;= n ny \u0026gt;= m: continue if graph[nx][ny]==0: continue if graph[nx][ny]==1: graph[nx][ny] = graph[x][y] + 1 queue.append((nx, ny)) return graph[n-1][m-1] "},{"id":20,"href":"/docs/mystudy/algorithm-note/part2/5_dfs_bfs/%EC%9D%8C%EB%A3%8C%EC%88%98-%EC%96%BC%EB%A0%A4-%EB%A8%B9%EA%B8%B0/","title":"음료수 얼려 먹기","section":"5. DFS \u0026 BFS","content":" 음료수 얼려 먹기 # Input # 얼음 틀의 세로길이 N, 가로길이 M (1 \u0026lt;= N, M \u0026lt;= 1,000) 두번째 줄부터 N+1번째 줄까지 얼음 틀의 형태가 주어짐 구멍이 뚫려있는 부분은 0, 그렇지 않은 부분은 1 Output # 한 번에 만들 수 있는 아이스크림의 갯수 구하기 Example # 입력 출력 15 14 00000111100000 11111101111110 11011101101110 11011101100000 11011111111111 11011111111100 11000000011111 01111111111111 00000000011111 01111111111000 00011111111000 00000001111000 11111111110011 1110001111111111100011111111 8 My Solution # # INPUT n, m = map(int, input().split()) graph = [] for i in range(n): graph.append(list(map(int, input()))) # SOLUTION from collections import deque def bfs(graph, start, N, M): \u0026#34;\u0026#34;\u0026#34; start 지점에서 시작하여 0인 영역을 모두 탐색하는 함수 \u0026#34;\u0026#34;\u0026#34; q = deque([start]) graph[start[0]][start[1]] = 0 while q: vi, vj = q.popleft() for i, j in [[vi+1, vj], [vi-1, vj], [vi, vj+1], [vi, vj-1]]: if i \u0026lt; 0 or i \u0026gt;= N or j \u0026lt; 0 or j \u0026gt;= M: continue if graph[i][j]==0: q.append([i, j]) graph[i][j] = 1 def solution(N, M, frame): i, j = 0, 0 res = 0 for i in range(N): for j in range(M): if frame[i][j] == 0: bfs(frame, [i, j], N, M) res += 1 else: continue return res # OUTPUT print( solution(N, M, frame) ) Solution # # N, M을 공백을 기준으로 구분하여 입력 받기 n, m = map(int, input().split()) # 2차원 리스트의 맵 정보 입력 받기 graph = [] for i in range(n): graph.append(list(map(int, input()))) # DFS로 특정한 노드를 방문한 뒤에 연결된 모든 노드들도 방문 def dfs(x, y): # 주어진 범위를 벗어나는 경우에는 즉시 종료 if x \u0026lt;= -1 or x \u0026gt;= n or y \u0026lt;= -1 or y \u0026gt;= m: return False # 현재 노드를 아직 방문하지 않았다면 if graph[x][y] == 0: # 해당 노드 방문 처리 graph[x][y] = 1 # 상, 하, 좌, 우의 위치들도 모두 재귀적으로 호출 dfs(x - 1, y) dfs(x, y - 1) dfs(x + 1, y) dfs(x, y + 1) return True return False # 모든 노드(위치)에 대하여 음료수 채우기 result = 0 for i in range(n): for j in range(m): # 현재 위치에서 DFS 수행 if dfs(i, j) == True: result += 1 print(result) # 정답 출력 "},{"id":21,"href":"/docs/mystudy/algorithm-note/part2/6_%EC%A0%95%EB%A0%AC/%EC%84%B1%EC%A0%81%EC%9D%B4%EB%82%AE%EC%9D%80%EC%88%9C%EC%84%9C%EB%A1%9C/","title":"성적이낮은순서로","section":"6. 정렬","content":" 성적이 낮은 순서로 학생 출력하기 # INPUT # 첫번째 줄 - 학생 수 N (1\u0026lt;=N\u0026lt;=100,000) 학생의 이름 문자열 A, 학생의 성적 B가 공백으로 구분되어 입력 학생의 성적 B는 100이하의 자연수 학생의 이름 A는 100 이하의 길이 OUTPUT # 모든 학생의 이름을 성적이 낮은 순서대로 출력 성적이 동일한 학생의 순서는 자유롭게 출력 My Solution # # SOLUTION def solution(scores): sorted_list = [[] for _ in range(101)] for n, s in scores: sorted_list[s].append(n) for names in sorted_list: for name in names: print(name, end=\u0026#39; \u0026#39;) # TEST N = int(input()) scores = [] for _ in range(N): name, score = input().split() scores.append([name, int(score)]) solution(scores) Solution # N = int(input()) array = [] for _ in range(N): name, score = input().split() array.append([name, int(score)]) array = sorted(array, key=lambda x:x[1]) for student in array: print(student[0], end=\u0026#39; \u0026#39;) "},{"id":22,"href":"/docs/mystudy/algorithm-note/part2/6_%EC%A0%95%EB%A0%AC/%EC%9C%84%EC%97%90%EC%84%9C%EC%95%84%EB%9E%98%EB%A1%9C/","title":"위에서아래로","section":"6. 정렬","content":" 위에서 아래로 # INPUT # 첫째줄 - 수열에 속해있는 수의 개수 N, (1 \u0026lt;= N \u0026lt;= 500) 둘째줄부터 N개의 수 입력됨 (범위 1~100,000의 자연수) OUTPUT # 입력으로 주어진 수열이 내림차순으로 정렬된 결과를 공백으로 구분하여 출력 Example # INPUT OUTPUT 3152712 27 15 12 My Solution # # SOLUTION def solution(arr): cnt_list = [0 for _ in range(100001)] for v in arr: cnt_list[v] += 1 for i in range(100000, -1, -1): for _ in range(cnt_list[i]): print(i, end=\u0026#39; \u0026#39;) # TEST N = int(input()) arr = [] for _ in range(N): arr.append(int(input())) solution(arr) Solution # # N 입력받기 N = int(input()) # N개의 정수 입력받아 리스트에 저장 arr = [] for _ in range(N): arr.append(int(input())) # 정렬 arr = sorted(arr, reverse=True) for i in arr: print(i, end=\u0026#39; \u0026#39;) "},{"id":23,"href":"/docs/mystudy/algorithm-note/part2/6_%EC%A0%95%EB%A0%AC/%EC%A0%95%EB%A0%AC%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EA%B3%84%EC%88%98%EC%A0%95%EB%A0%AC/","title":"계수정렬","section":"6. 정렬","content":" 계수 정렬 # 특정한 조건이 부합할 때만 사용할 수 있지만, 매우 빠른 정렬 알고리즘 데이터가 모두 양의 정수이며, 데이터의 개수가 N, 최댓값이 K일 때, 계수 정렬은 최악의 경우에도 수행시간 $O(N+K)$을 보장함 매우 빠르게 동작하며, 매우 간단한 원리 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때만 사용 가능 실수형 데이터로 주어질 때 사용하기 어려움 일반적으로는 가장 큰 데이터와 가장 작은 데이터의 차이가 1,000,000을 넘지 않을 때 효과적 데이터의 범위가 너무 크면 계수정렬을 사용할 수 없음. 계수정렬을 이용할 때에는 모든 범위를 담을 수 있는 크기의 리스트(배열)를 선언하기 때문 계수 정렬은 비교 기반의 정렬 알고리즘이 아니다. 계수정렬 소스코드\n# SOLUTION def sorting(arr): a, b = min(arr), max(arr) cnt_list = [0 for _ in range(b-a+1)] for v in arr: cnt_list[v-a] += 1 sorted_list = [] for i in range(b-a+1): for _ in range(cnt_list[i]): sorted_list.append(a+i) return sorted_list 시간복잡도 # 데이터가 정수, 데이터의 개수가 N, 최대값이 K일 때, $O(N+K)$ 데이터를 하나씩 확인하면서 최소, 최댓값을 확인하며, 인덱스의 값을 1씩 증가시키는 동작을 하며, 리스트의 각 인덱스에 해당하는 값들을 확인할 때 최댓값의 크기만큼 반복 수행하기 때문 사실 상 현존하는 정렬 알고리즘 중 기수 정렬과 더불어 가장 빠르다. 공간복잡도 # 때에 따라 심각한 비효율성을 초래할 수도 있음. (ex. 데이터가 0과 999,999 만 있을 때) 동일한 값을 가지는 데이터가 여러 개 등장할 때 적합 (ex. 성적) 크기가 한정되어 있고, 데이터가 많이 중복되어 있을수록 유리 "},{"id":24,"href":"/docs/mystudy/algorithm-note/part2/6_%EC%A0%95%EB%A0%AC/%EC%A0%95%EB%A0%AC%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%82%BD%EC%9E%85%EC%A0%95%EB%A0%AC/","title":"삽입정렬","section":"6. 정렬","content":" 삽입정렬 # 데이터를 하나씩 확인하며, 각 데이터의 적절한 위치에 삽입하면 어떨까? 선택정렬에 비해 구현 난이도가 높은 편이지만, 실행 시간 측면에서 더 효율적인 알고리즘 특히 삽입 정렬은 필요할 때만 위치를 바꾸기 때문에 \u0026ldquo;데이터가 거의 정렬되어 있을 때\u0026rdquo; 효율적 특정한 데이터를 적절한 위치에 \u0026ldquo;삽입\u0026quot;한다는 의미 삽입정렬 방법 특정한 데이터가 적절한 위치에 들어가기 이전에 그 앞까지의 데이터는 이미 정렬되어 있다고 가정 정렬되어 있는 리스트에 적절한 위치를 찾은 뒤, 그 위치에 삽입 특정 데이터가 삽입될 위치를 선정할 때(왼쪽으로 한 칸씩 이동하며 탐색할 때), 삽입될 데이터보다 작은 데이터를 만나면, 그 위치에서 멈춤 삽입정렬 소스코드\n# INPUT arr = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8] # SOLUTION def insert_sorting(arr): for i in range(1, len(arr)): for j in range(i-1, -1, -1): if arr[i] \u0026gt; arr[j]: arr.insert(j+1, arr.pop(i)) break else: arr.insert(0, arr.pop(i)) # OUTPUT insert_sorting(arr) print(arr) 삽입정렬의 시간복잡도도 $O(N^2)$ 이지만, 리스트가 거의 정렬되어 있는 상태라면 퀵 정렬보다 빠를 수 있다. "},{"id":25,"href":"/docs/mystudy/algorithm-note/part2/6_%EC%A0%95%EB%A0%AC/%EC%A0%95%EB%A0%AC%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%EC%84%A0%ED%83%9D%EC%A0%95%EB%A0%AC/","title":"선택정렬","section":"6. 정렬","content":" 선택 정렬 # 매번 가장 작은 것을 선택한다는 의미의 알고리즘 가장 작은 데이터를 맨 앞에 있는 데이터와 바꾸고,\n그 다음 작은 데이터를 두 번째 데이터와 바꾸고 \u0026hellip; 이런 과정을 반복 # INPUT arr = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8] # SOLUTION def select_sorting(arr): for i in range(len(arr)): min_i = i for j in range(i+1, len(arr)): if arr[j] \u0026lt; arr[min_i]: min_i = j arr[i], arr[min_i] = arr[min_i], arr[i] # OUTPUT select_sorting(arr) print(arr) 선택 정렬의 시간복잡도는 $N + (N-1) + \\dots + 2$ 로 $O(N^2)$ 이다. 만약 정렬해야할 개수가 100배 늘어마녀 이론적으로 수행시간은 10,000배 늘어난다. 선택 정렬은 기본 라이브러리를 포함해 다른 알고리즘과 비교했을 때 매우 비효율적 데이터의 개수(N) 선택정렬 퀵 정렬 기본 정렬 라이브러리 N = 100 0.0123s 0.00156s 0.00000753s N = 1,000 0.354s 0.00343s 0.0000365 N = 10,000 15.475s 0.0312 0.00028s "},{"id":26,"href":"/docs/mystudy/algorithm-note/part2/6_%EC%A0%95%EB%A0%AC/%EC%A0%95%EB%A0%AC%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/%ED%80%B5%EC%A0%95%EB%A0%AC/","title":"퀵정렬","section":"6. 정렬","content":" 퀵 정렬 # 정렬 알고리즘 중 가장 많이 사용되는 알고리즘\n퀵 정렬과 비교할만큼 빠른 알고리즘으로 \u0026lsquo;병합 정렬\u0026rsquo;이 있음.\n퀵 정렬과 병합 정렬은 대부분의 프로그래밍 언어에서 정렬 라이브러리의 근간이 되는 알고리즘이기도 함.\n기준을 설정한 다음 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식으로 동작\n퀵 정렬에서는 피벗(Pivot)이 사용된다.\n큰 숫자와 작은 숫자를 교환할 때, 교환하기 위한 \u0026lsquo;기준\u0026rsquo;을 피벗이라고 표현\n피벗을 어떻게 설정하고 리스트를 분할하는지에 따라 여러 가지 방식의 퀵 정렬이 있다.\n호어 분할 방식\n리스트에서 첫 번째 데이터를 피벗으로 정함 왼쪽에서부터 피벗보다 큰 데이터를 찾고, 오른쪽에서부터 피벗보다 작은 데이터를 찾음 큰 데이터와 작은 데이터의 위치를 서로 교환 이어서 왼쪽부터 큰 데이터를, 오른쪽부터 작은 데이터를 찾은 뒤 교환 이 과정을 반복 왼쪽에서 찾던 값과 오른쪽에서 찾던 값이 엇갈릴 때, 작은 데이터와 피벗의 위치를 교환한다. 그러면 피벗을 기준으로 왼쪽은 모두 피벗보다 작은 데이터들, 오른쪽은 모두 피벗보다 큰 데이터들로 이루어져 있다. (분할 완료) 이 상태에서 왼쪽리스트와 오른쪽 리스트에서도 각각 피벗을 설정하여 동일한 방식으로 정렬 수행 반복 퀵정렬 소스코드\ndef quick_sort(arr, start, end): if start \u0026gt;= end: return pv = start l = start + 1 r = end while l \u0026lt;= r: # 인덱스 찾기 while l \u0026lt;= end and arr[l] \u0026lt;= arr[pv]: l += 1 while r \u0026gt; start and arr[r] \u0026gt;= arr[pv]: r -= 1 # 교환 if l \u0026gt; r: arr[pv], arr[r] = arr[r], arr[pv] else: arr[r], arr[l] = arr[l], arr[r] quick_sort(arr, start, r-1) quick_sort(arr, r+1, end) python의 장점을 살린 퀵 정렬 소스코드\ndef quick_sort(arr): if len(arr) \u0026lt;= 1: return arr pv = arr[0] tail = arr[1:] left = [x for x in tail if x \u0026lt;= pv] right = [x for x in tail if x \u0026gt; pv] return quick_sort(left) + [pv] + quick_sort(right) 시간 복잡도 # 선택정렬, 삽입정렬의 시간복잡도 $=O(N^2)$ 퀵 정렬의 평균적인 시간 복잡도 $=O(NlogN)$ 퀵 정렬의 최악의 경우 시간 복잡도 $=O(N^2)$ 무작위로 입력되는 데이터에서는 빠르게 동작할 확률이 높지만, 이미 데이터가 정렬되어 있는 경우에는 매우 느리게 동작한다. (삽입 정렬과 반대) "},{"id":27,"href":"/docs/mystudy/algorithm-note/part2/7_%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89/%EB%96%A1%EB%B3%B6%EC%9D%B4%EB%96%A1%EB%A7%8C%EB%93%A4%EA%B8%B0/","title":"떡볶이떡만들기","section":"7. 이진탐색","content":" 떡볶이 떡 만들기 # INPUT # 첫째줄: N, M = 떡의 개수, 요청한 떡의 길이\n($1\\le N \\le 1,000,000, 1\\le M \\le 2,000,000,000$) 둘째줄: 떡의 개별 높이 떡의 개별 높이의 총합은 항상 M 이상. 높이는 1,000,000,000보다 작거나 같은 양의 정수 또는 0 OUTPUT # 적어도 M만큼 떡을 가져가기 위해 절단기에 설정할 수 있는 높이의 최댓값 Example # 문제 # 절단기에 높이 H를 설정하면, 높이가 H보다 긴 떡만 H 위의 부분이 잘림. 예) 19, 14, 14, 17cm 의 떡들을 15cm로 설정한 절단기로 자르면, 15, 14, 14, 15cm가 되고, 잘린 떡은 4, 0, 0, 2cm이며, 총 잘린 6cm의 떡을 가져갈 수 있다. My Solution # def binary_search(arr, target, s, e): \u0026#34;\u0026#34;\u0026#34;이진탐색 코드의 변형 arr내에 target이 없을 때 없다고 반환하지 않고, 큰 값을 반환\u0026#34;\u0026#34;\u0026#34; if s \u0026gt; e: return s m = (s+e)//2 if arr[m] \u0026lt; target: return binary_search(arr, target, m+1, e) elif arr[m] \u0026gt; target: return binary_search(arr, target, s, m-1) else: return m def solution(arr, N, M): \u0026#34;\u0026#34;\u0026#34;떡볶이 떡 길이 계산\u0026#34;\u0026#34;\u0026#34; arr.sort(reverse=True) # diff \u0026amp; cnt 만들기 arr_dup = [] cnts = [] diffs = [] c = 0 for i in range(N-1): d = arr[i] - arr[i+1] c += 1 if d != 0: arr_dup.append(arr[i]) cnts.append(c) diffs.append(d) arr_dup.extend([arr[-1], 0]) cnts.append(c+1) diffs.append(arr[-1]) # dduck_diff dduk_diff = [d*c for d,c in zip(diffs, cnts)] # dduck s = 0 dduk = [] for dd in dduk_diff: s += dd dduk.append(s) idx = binary_search(dduk, M, 0, len(dduk)-1) return arr_dup[idx+1] + (dduk[idx] - M)//cnts[idx] # TEST N, M = 4, 6 arr = [19, 15, 10, 17] print(solution(arr, N, M)) # 15 N, M = 5, 6 arr = [19, 15, 10, 17, 17] print(solution(arr, N, M)) # 15 N, M = 6, 6 arr = [19, 15, 10, 17, 17, 19] print(solution(arr, N, M)) # 16 N, M = 6, 30 arr = [19, 15, 10, 17, 17, 19] print(solution(arr, N, M)) # 11 N, M = 6, 50 arr = [19, 15, 10, 17, 17, 19] print(solution(arr, N, M)) # 7 N, M = 6, 97 arr = [19, 15, 10, 17, 17, 19] print(solution(arr, N, M)) # 0 시간복잡도 = $Nlog_2N + 7N + log_2N=O(Nlog_2N)$ 최악의 경우 대략 27,000,000번의 연산 필요 문제 해설 # 전형적인 이진 탐색 문제, 파라메트릭 서치 유형의 문제\n파라메트릭 서치 : 최적화 문제를 결정문제로 바꾸어 해결하는 기법\n\u0026ldquo;원하는 조건을 만족하는 가장 알맞은 값을 찾는 문제\u0026quot;에 주로 파라메트릭 서치를 사용\n예를 들어, 범위 내에서 조건을 만족하는 가장 큰 값을 찾으라는 최적화 문제라면 이진탐색으로 결정 문제를 해결하면서 범위를 좁혀갈 수 있다.\n코테나 대회에서는 보통 파라메트릭 서치 유형은 이진 탐색을 이용하여 해결\n이 문제의 풀이 아이디어 - 적절한 높이를 찾을 때까지 절단기의 높이 H를 반복해서 조정하는 것\n높이 H를 이진 탐색으로 찾으면 $log_21,000,000,000 = 29.9$으로 대략 31번(?)만에 찾을 수 있다.\n이때 떡의 개수 N 이 최대 1,000,000개 이므로 높이 한번에 1,000,000번 연산이 필요하므로 대략 최대 3,000만번 정도의 연산으로 문제를 풀 수 있다.\n# 입력받기 n, m = list(map(int, input().split(\u0026#39; \u0026#39;))) array = list(map(int, input().split())) # 이진탐색의 시작과 끝점 start = 0 end = max(array) # 이진 탐색 수행 result = 0 while start \u0026lt;= end: total = 0 mid = (start + end) // 2 for x in array: if x \u0026gt; mid: total += (x - mid) if total \u0026lt; m: end = mid - 1 else: result = mid start = mid + 1 print(result) 해설 읽고 작성한 코드\ndef calcul(arr, H): S = 0 for a in arr: S += a - H if a \u0026gt; H else 0 return S def solution(arr, N, M): s, e = 0, max(arr) while True: if s \u0026gt; e: return e m = (s+e)//2 D = calcul(arr, m) if D \u0026lt; M: e = m - 1 elif D \u0026gt; M: s = m + 1 else: return m "},{"id":28,"href":"/docs/mystudy/algorithm-note/part2/7_%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89/%EB%B6%80%ED%92%88%EC%B0%BE%EA%B8%B0/","title":"부품찾기","section":"7. 이진탐색","content":" 부품 찾기 # INPUT # $N$ : 탐색할 배열의 크기 ($1 \\le N \\le 1,000,000$) 공백으로 구분된 N개의 정수: 탐색할 배열, $1 \u0026lt; 정수 \\le 1,000,000$ $M$ : 찾으려는 숫자의 갯수 ($1 \\le M \\le 100,000$) 공백으로 구분된 M개의 정수: 탐색할 값, ($1 \u0026lt; N \\le 1,000,000$) OUTPUT # 찾으려는 값들의 존재 여부를 yes, no로 출력 Example # Input Output 58 3 7 9 235 7 9 no yes yes My Solution # # SOLUTION def binary_search(arr, target, s, e): if e \u0026lt; s: return -1 m = (s+e)//2 if arr[m] \u0026lt; target: return binary_search(arr, target, m+1, e) elif arr[m] \u0026gt; target: return binary_search(arr, target, s, m-1) else: return arr[m] def solution(arr, targets, N): arr.sort() for t in targets: if binary_search(arr, t, 0, N-1) != -1: print(\u0026#34;yes\u0026#34;, end=\u0026#34; \u0026#34;) else: print(\u0026#34;no\u0026#34;, end=\u0026#34; \u0026#34;) Solution # def solution(arr, targets, N): arr_sort = [0] * 1000001 for a in arr: arr_sort[a] = 1 for t in targets: if arr_sort[t]: print(\u0026#34;yes\u0026#34;, end=\u0026#34; \u0026#34;) else: print(\u0026#34;no\u0026#34;, end=\u0026#34; \u0026#34;) # TEST N = 5 arr = [8, 3, 7, 9, 2] M = 3 targets = [5, 7, 9] solution(arr, targets, N) "},{"id":29,"href":"/docs/mystudy/algorithm-note/part2/7_%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89/%EC%A7%95%EA%B2%80%EB%8B%A4%EB%A6%AC%EA%B1%B4%EB%84%88%EA%B8%B0/","title":"징검다리건너기","section":"7. 이진탐색","content":" 프로그래머스 - 징검다리 건너기 # 문제 링크 : 링크\nInput # 디딤돌에 적힌 숫자가 순서대로 담긴 배열 stones 한 번에 건너뛸 수 있는 디딤돌의 최대 칸수 k 디딤돌에는 모두 숫자가 적혀 있으며 디딤돌의 숫자는 한 번 밟을 때마다 1씩 줄어듭니다. 디딤돌의 숫자가 0이 되면 더 이상 밟을 수 없으며 이때는 그 다음 디딤돌로 한번에 여러 칸을 건너 뛸 수 있습니다. 단, 다음으로 밟을 수 있는 디딤돌이 여러 개인 경우 무조건 가장 가까운 디딤돌로만 건너뛸 수 있습니다 Output # 최대 몇 명까지 징검다리를 건널 수 있는지 return 입력과 출력 예 # stones k result [2, 4, 5, 3, 2, 1, 4, 2, 5, 1] 3 3 나의 풀이 코드 # 통과 (313.83ms, 18.6MB)\ndef check(stones, k, mid): cnt = 0 for stone in stones: if stone \u0026lt;= mid: cnt += 1 else: cnt = 0 if cnt \u0026gt;= k: return False return True def binary_search(stones, k, s, e): while s \u0026lt;= e: mid = (s+e)//2 if check(stones, k, mid): s = mid + 1 else: e = mid - 1 return s def solution(stones, k): s = 1 e = max(stones) return binary_search(stones, k, s, e) $O(?)$ 이게 왜 빠르지..? 솔루션 보고 풀었다. 이진탐색을 데이터를 탐색하는 데 쓴 것이 아닌 정답을 찾아가는 데 이진탐색을 썼다. 정답이 mid보다 큰지 작은지 확인하고, s,e를 조정해가며 정답을 찾는 방법 함수 binary_search - 이진탐색 함수의 변형 check - mid명이 지나갈 수 있는지 확인하는 함수 binary_search 에서 mid 값이 정답일때는 어떻게 되나 생각했는데,\ns = e 로 수렴하고, 마지막 loop에서 s + 1을 return 하게되면서 해결 더 빠른 풀이 코드 # 통과 (19.82ms, 18.5MB)\ndef solution(stones, k): cnt = 200000000 pointer = 0 change = 0 while pointer \u0026lt; len(stones) - (k-1): pointer += stones[pointer:pointer+k].index(max(stones[pointer:pointer+k])) if cnt \u0026gt; stones[pointer]: cnt = stones[pointer] change+=1 pointer += 1 if change \u0026gt;= 15: break if change \u0026lt; 15: return cnt else: cnt = [] pointer = 0 while pointer \u0026lt; len(stones) - (k-1): cnt.append(max(stones[pointer:pointer+k])) pointer += k return min(cnt) $O(S \\times k)$ $S$ : stones의 길이 $k$ : input k 처음에 생각했던 방법과 비슷하지만, 효율성에서 통과하지 못했던 것 이 코드는 조금 더 불필요한 계산들을 쳐낸 듯 좀 더 공부해야 함! 이진탐색 # 이진탐색이 적용가능한 경우 # 단조증가 함수일때 한 점에서만 변하는 조건함수를 정의할 수 있을 때\n$g(x) = \\begin{cases} 0, ;(x\u0026lt;0)\\ 1, ;(x\\geq 0) \\end{cases}$ 이진탐색 조건 설정하기 # low, high 불변의 법칙? $g(low)=0$, $g(high)=1$ 를 항상 만족하도록 하면 됨. (반대일 경우라도) low, high 를 계속 수정해 나갈때에 위 조건을 만족하도록 low 또는 high를 수정하면 됨. "},{"id":30,"href":"/docs/mystudy/algorithm-note/part2/8_%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/1%EB%A1%9C%EB%A7%8C%EB%93%A4%EA%B8%B0/","title":"1로만들기","section":"8. DP","content":" 1로 만들기 # 정수 X에 대해 4가지 연산을 사용해 1을 만들려고 함. 최소한의 연산횟수를 구하기.\n연산\nX가 5로 나누어 떨어지면, 5로 나눈다. X가 3로 나누어 떨어지면, 3으로 나눈다. X가 2로 나누어 떨어지면, 2로 나눈다. X에서 1을 뺀다. INPUT # 첫째줄 정수 X 1 \u0026lt;= X \u0026lt;= 30,000 OUTPUT # 최소한의 연산 횟수 My Solution # 연산1이 항상 연산2보다 좋다고 할 수 없음.\n(연산2가 항상 연산3보다 좋을 수 없으며, 연산3이 항상 연산4보다 좋을 수 없음.) =\u0026gt; greedy 아님 어느정도 탐색과 모험?이 필요함. X가 5로 나누어 떨어진다면, f(X)는 f(X//5)+1이 될 수도 있음. f(X//5) 또한 최소한의 연산횟수일 거기 때문에 그렇다면, 상향식이 좋을까? 하향식이 좋을까? 하향식이 최소한의 연산을 쓸 것 같아서 좋지만, 스택공간이 부족할 것 같기도 함 상향식이면.. 어떻게 연산할 숫자들을 \u0026hellip;? # SOLUTION noprs = [0]*30001 def solution(x): if x == 1 or noprs[x]!=0: return noprs[x] oprs = [] if x%5==0: oprs.append(solution(x//5)) if x%3==0: oprs.append(solution(x//3)) if x % 2 == 0: oprs.append(solution(x//2)) oprs.append(solution(x-1)) noprs[x] = min(oprs)+1 return noprs[x] # INPUT X = int(input()) print(solution(X)) Book Solution # Bottom-Up\nx = int(input()) # DP 테이블 d = [0] * 30001 # Bottom-Up for i in range(2, x+1): d[i] = d[i-1] + 1 if i % 2 == 0: d[i] = min(d[i], d[i//2] + 1) if i % 3 == 0: d[i] = min(d[i], d[i//3] + 1) if i % 5 == 0: d[i] = min(d[i], d[i//5] + 1) print(d[x]) 시간복잡도 = $4X = O(X)$ "},{"id":31,"href":"/docs/mystudy/algorithm-note/part2/8_%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%EA%B0%9C%EB%AF%B8%EC%A0%84%EC%82%AC/","title":"개미전사","section":"8. DP","content":" 개미전사 # 메뚜기 마을의 식량창고는 일직선상에 있음. 개미전사가 메뚜기의 식량창고를 선택적으로 약탈하여 식량을 뺏을 예정\n하지만, 메뚜기들은 인접한 식량창고가 털리면 바로 알아챔. 고로, 최소 한 칸 이상 떨어진 식량창고를 약탈할 수 있음. 최대한 많이 얻을 수 있는 식량은?\nINPUT # 첫째줄에 식량창고의 개수 N, 3 \u0026lt;= N \u0026lt;= 100 둘째줄에 공백으로 구분된 식량창고에 저장된 식량의 개수 K 0 \u0026lt;= K \u0026lt;= 1000 OUTPUT # 개미전사가 얻을 수 있는 식량의 최댓값 Example # 입력 출력 41 3 1 5 8 My Solution # def solution(N, arr): dp_arr = arr[:2] + [0]*(N-2) for i in range(2, N): dp_arr[i] = max(dp_arr[i-1], dp_arr[i-2] + arr[i]) return dp_arr[-1] # INPUT N = int(input()) arr = list(map(int, input().split())) # OUTPUT print(solution(N, arr)) "},{"id":32,"href":"/docs/mystudy/algorithm-note/part2/8_%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%EB%B0%94%EB%8B%A5%EA%B3%B5%EC%82%AC/","title":"바닥공사","section":"8. DP","content":" 바닥공사 # 세로 x 가로가 2 x N인 바닥에 1x2 2x1 2x2 인 타일을 덮는 경우의 수 구하기\nINPUT # 가로길이 N 1 \u0026lt;= N \u0026lt;= 1,000 OUTPUT # 바닥을 채우는 방법의 수를 796,796으로 나눈 나머지 구하기 My Solution # 세로가 무조건 2니까 2x2 공간을 덮는 경우의 수는 3가지 하지만 무조건 2칸으로 다 나눌 수는 없다! 개미전사 문제처럼 앞에서부터 한칸씩 풀면 될까? 가로가 N일때 경우의 수는 (N-1일 때 방법의 수) + (N-2일 때 방법의 수)*2 def solution(N): arr = [0]*N arr[0] = 1 arr[1] = 3 for i in range(2, N): arr[i] = (arr[i-1] + 2*arr[i-2]) % 796796 return arr[-1] # INPUT \u0026amp; OUTPUT N = int(input()) print(solution(N)) "},{"id":33,"href":"/docs/mystudy/algorithm-note/part2/8_%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8%ED%99%94%ED%8F%90%EA%B5%AC%EC%84%B1/","title":"효율적인화폐구성","section":"8. DP","content":" 효율적인 화폐 구성 # N가지 종류의 화폐로 최소한의 갯수를 사용해서 M원 만들기.\nINPUT # 화폐의 종류 수 N 1 \u0026lt;= N \u0026lt;= 100 만들려는 목표 금액 M 1 \u0026lt;= M \u0026lt;= 10,000 OUTPUT # M원을 만들기 위한 최소한의 화폐 개수 불가능할 때는 -1 My Solution # def solution(M, coins): d = [0] + [-1]*10000 for i in range(1, M+1): dmin = 10001 for c in coins: if i-c \u0026gt;= 0 and d[i-c] \u0026gt;= 0: dmin = min(dmin, d[i-c]) dmin = dmin + 1 if dmin!=10001 else -1 d[i] = dmin return d[M] # INPUT N, M = map(int, input().split()) coins = [] for _ in range(N): coins.append(int(input())) # OUTPUT print(solution(M, coins)) "},{"id":34,"href":"/docs/mystudy/algorithm-note/part3/11_greedy/%EA%B3%B1%ED%95%98%EA%B8%B0-%ED%98%B9%EC%9D%80-%EB%8D%94%ED%95%98%EA%B8%B0/","title":"곱하기 혹은 더하기","section":"그리디 알고리즘","content":" 곱하기 혹은 더하기 # Input # S : 첫째 줄에 주어지는 여러 개의 숫자로 구성된 문자열 (1 \u0026lt;= S의 길이 \u0026lt;= 20) Output # 만들어질 수 있는 가장 큰 수 Rule # 왼쪽부터 오른쪽으로 하나씩 모든 숫자 사이에 \u0026ldquo;x\u0026rdquo; 혹은 \u0026ldquo;+\u0026rdquo; 연산자를 넣어 만들어질 수 있는 가장 큰 수 구하기 연산 순서는 \u0026ldquo;x\u0026rdquo;, \u0026ldquo;+\u0026rdquo; 상관 없이 무조건 왼쪽부터 순서대로 Example # 입력 출력 02984 576 567 210 My Solution # def solution(S): S = list(S) res = int(S.pop(0)) for n in S: res = max(res+int(n), res*int(n)) return res S = input() print(solution(S)) Answer # data = input() # 첫 번째 문자를 숫자로 변경하여 대입 result = int(data[0]) for i in range(1, len(data)): # 두 수 중에서 하나라도 \u0026#39;0\u0026#39; 혹은 \u0026#39;1\u0026#39;인 경우, 곱하기보다는 더하기 수행 num = int(data[i]) if num \u0026lt;= 1 or result \u0026lt;= 1: result += num else: result *= num print(result) "},{"id":35,"href":"/docs/mystudy/algorithm-note/part3/11_greedy/%EB%A7%8C%EB%93%A4%EC%88%98%EC%97%86%EB%8A%94%EA%B8%88%EC%95%A1/","title":"만들수없는금액","section":"그리디 알고리즘","content":" 만들 수 없는 금액 # Input # 첫째 줄: 에 입력되는 동전의 개수 N (1 \u0026lt;= N \u0026lt;= 1,000) 둘째 줄: 각 동전의 화폐 단위를 나타나는 N개의 자연수, Output # 첫째 줄에 주어진 동전들로 만들 수 없는 양의 정수 금액 중 최솟값 Rule # N개의 동전을 이용하여 만들 수 없는 양의 정수 금액 중 최솟값을 구하는 프로그램 작성 Example # 입력 출력 5 3 2 1 1 9 8 My Solution # import heapq def solution(coins): coins.sort(reverse = True) sums = set() n = 1 while True: if n in sums: n += 1 continue elif not coins or (coins[-1] \u0026gt; n): return n else: c = coins.pop() sums = sums.union({s+c for s in sums}) sums.add(c) _ = input() coins = list(map(int, coins.split())) print(solution(coins)) Answer # n = int(input()) data = list(map(int, input().split())) data.sort() target = 1 for x in data: if target \u0026lt; x: break target += x print(target) data에서 $x_i$까지 탐색했을 때, $T$원 까지 만들 수 있었다고 하자. 다음 $x_{i+1}$을 볼 때, $x_{i+1} \\leq T \\Rightarrow T+1$ ~ $T+x_{i+1}$원까지도 모두 만들 수 있음. $x_{i+1} \u0026gt; T \\Rightarrow T+1$원을 만들 수 없음. "},{"id":36,"href":"/docs/mystudy/algorithm-note/part3/11_greedy/%EB%AA%A8%ED%97%98%EA%B0%80%EA%B8%B8%EB%93%9C/","title":"모험가길드","section":"그리디 알고리즘","content":" 모험가 길드 # Input # N : 첫째 줄에 주어지는 모험가의 수 1 \u0026lt;= N \u0026lt;= 100,000 각 모험가의 공포도 : 둘째 줄에 주어지는 N이하의 자연수 값들, 공백으로 구분됨 Output # 여행을 떠날 수 있는 그룹 수의 최대값 Rule # 공포도가 X인 모험가는 반드시 X명 이상으로 구성한 모험가 그룹에 참여해야 여행을 떠날 수 있음 최대로 만들 수 있는 모험감의 그룹? Example # 입력 출력 5 2 3 1 2 2 2 "},{"id":37,"href":"/docs/mystudy/algorithm-note/part3/11_greedy/%EB%B3%BC%EB%A7%81%EA%B3%B5%EA%B3%A0%EB%A5%B4%EA%B8%B0/","title":"볼링공고르기","section":"그리디 알고리즘","content":" 볼링공 고르기 # Input # 첫째줄 N, M : 볼링공의 갯수 N, 공의 최대 무게 M 둘째줄 각 볼링공의 무게 K : 순서대로 자연수 1 \u0026lt;= N \u0026lt;= 1,000, 1 \u0026lt;= M \u0026lt;=10 1 \u0026lt;= K \u0026lt;= M Output # 두 사람이 볼링공을 고르는 경우의 수 출력 Rule # 두 사람이 서로 다른 무게의 볼링공을 고르도록 한다. Example # 입력 출력 5 3 1 3 2 3 2 8 8 5 1 5 4 3 2 4 5 2 25 My Solution # from collections import Counter def solution(N, data): cnt = Counter(data) res = N * (N-1) for k,v in cnt.items(): if v \u0026gt; 1: res -= (v*(v-1)) return res//2 N, M = map(int, input().split()) data = list(map(int, input().split())) print(N, data) Answer # n, m = map(int, input().split()) data = list(map(int, input().split())) # 1부터 10까지의 무게를 담을 수 있는 리스트 array = [0] * 11 for x in data: # 각 무게에 해당하는 볼링공의 개수 카운트 array[x] += 1 result = 0 # 1부터 m까지의 각 무게에 대하여 처리 for i in range(1, m + 1): n -= array[i] # 무게가 i인 볼링공의 개수(A가 선택할 수 있는 개수) 제외 result += array[i] * n # B가 선택하는 경우의 수와 곱해주기 print(result) "},{"id":38,"href":"/docs/mystudy/hidden/","title":"Hidden","section":"My Study","content":" This page is hidden in menu # Quondam non pater est dignior ille Eurotas # Latent te facies # Lorem markdownum arma ignoscas vocavit quoque ille texit mandata mentis ultimus, frementes, qui in vel. Hippotades Peleus pennas conscia cuiquam Caeneus quas.\nPater demittere evincitque reddunt Maxime adhuc pressit huc Danaas quid freta Soror ego Luctus linguam saxa ultroque prior Tatiumque inquit Saepe liquitur subita superata dederat Anius sudor Cum honorum Latona # O fallor in sustinui iussorum equidem. Nymphae operi oris alii fronde parens dumque, in auro ait mox ingenti proxima iamdudum maius?\nreality(burnDocking(apache_nanometer), pad.property_data_programming.sectorBrowserPpga(dataMask, 37, recycleRup)); intellectualVaporwareUser += -5 * 4; traceroute_key_upnp /= lag_optical(android.smb(thyristorTftp)); surge_host_golden = mca_compact_device(dual_dpi_opengl, 33, commerce_add_ppc); if (lun_ipv) { verticalExtranet(1, thumbnail_ttl, 3); bar_graphics_jpeg(chipset - sector_xmp_beta); } Fronde cetera dextrae sequens pennis voce muneris # Acta cretus diem restet utque; move integer, oscula non inspirat, noctisque scelus! Nantemque in suas vobis quamvis, et labori!\nvar runtimeDiskCompiler = home - array_ad_software; if (internic \u0026gt; disk) { emoticonLockCron += 37 + bps - 4; wan_ansi_honeypot.cardGigaflops = artificialStorageCgi; simplex -= downloadAccess; } var volumeHardeningAndroid = pixel + tftp + onProcessorUnmount; sector(memory(firewire + interlaced, wired)); "},{"id":39,"href":"/docs/mystudy/algorithm-note/part2/3_%EA%B7%B8%EB%A6%AC%EB%94%94/","title":"3. 그리디 알고리즘","section":"Part 2","content":" Greedy # 단순하지만 강력한 문제 해결 방법 현재 상황에서 지금 당장 좋은 것만 고르는 방법 현재의 선택이 나중에 미칠 영향에 대해서는 고려하지 않음 다익스트라 알고리즘은 엄밀히 말하면 Greedy 알고리즘 보통 코딩테스트에서 출제되는 Greedy 알고리즘 유형의 문제는 창의력, 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구 Greedy 알고리즘의 정당성 # greedy 알고리즘을 모든 문제에 적용할 수 있는 것은 아니다. Greedy로 정확한 답을 찾을 수 있다는 보장이 있을 때는 매우 효과적이고 직관적\n(greedy로 정확한 답이 도출된다는 증명을 머릿속으로 빠르게 할 수 있어야 함) 거스름돈 문제를 그리디 알고리즘으로 해결할 수 있는 이유:\n큰 단위의 동전이 항상 작은 단위 동전의 배수이므로 작은 단위의 동전들을 종합해 더 좋은 해가 나올 수 없기 때문이다. 대부분의 그리디 알고리즘 문제에서는 이처럼 문제 풀이를 위한 최소한의 아이디어를 떠올리고, 이것이 정당한지 검토할 수 있어야 답을 도출할 수 있다. 문제 # 큰 수의 법칙 숫자 카드 게임 1이 될 때까지 Reference # 책 : 이것이 취업을 위한 코딩테스트다 with 파이썬 "},{"id":40,"href":"/docs/mystudy/algorithm-note/part2/4_%EA%B5%AC%ED%98%84/","title":"4. 구현","section":"Part 2","content":" Implementation # 구현? 머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정 어떤 문제를 풀든 소스코드를 작성하는 과정은 필수이기 때문에 구현 문제는 모든 범위의 문제 유형을 포함한다. 취업 코딩테스트에서는 자주 출제됨 문제에 대한 정확한 풀이 방법이 떠오르면, 프로그래밍 언어로 정확히 구현해내야 함.\n프로그래밍 언어의 문법을 정확히 알고 있어야 하며, 문제의 요구사항에 어긋나지 않는 답안 코드를 작성해야함 구현 유형 문제 : 풀이를 떠올리는 것은 쉽지만, 소스코드로 옮기기 어려운 문제 흔히 개발할 때 프로그래밍 언어의 문법에 능숙하고 코드 작성속도가 빠른 사람을 보고 \u0026ldquo;피지컬이 좋다\u0026quot;고 한다. 그런 의미에서 구현 유형의 문제는 \u0026ldquo;피지컬을 요구하는\u0026rdquo; 문제라고도 할 수 있다. 대체로 사소한 조건 설정이 많은 문제일수록 코드로 구현하기 까다로움 문법을 정확하게 숙지하지 못했거나, 라이브러리 사용 경험이 부족하면 구현 유형에 불리 \u0026lsquo;구현\u0026rsquo; 유형으로 풀 수 있는 문제 완전탐색 : 모든 경우의 수를 주저 없이 다 계산하는 해결 방법 시뮬레이션 : 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행하는 방법 C/C++/JAVA 보다 파이썬에서 상대적으로 쉽게 해결할 수 있다. 구현 시 고려해야 할 메모리 제약 사항 # C/C++/JAVA 정수형 표현 범위 # 정수형 종류 자료형의 크기 자료형의 범위 int 4bytes -2,147,483,648~2,147,438,647 long 8bytes -9,223,372,036,854,775,808~9,223,372,036,854,775,807 BigInterger (클래스) 가변적 제한 없음 대체로 long 에서 다룰 수 있는 수보다 더 큰 정수를 처리하는 문제는 잘 출제되지 않는다. python에서는 직접 자료형을 지정할 필요가 없고, 매우 큰 수의 연산을 기본으로 지원 python에서 실수형 변수는 유효숫자에 따라서 연산 결과가 원하는 값이 나오지 않을 수 있다 (???) Python에서 리스트 크기에 따른 메모리 사용량 # 리스트의 길이 (int 자료형일때) 메모리 사용량 1,000 약 4KB 1,000,000 약 4MB 10,000,000 약 40MB 대체로 코딩테스트에서는 128~512MB로 메모리 제한 리스트 중 크기가 1,000만 이상인 리스트가 있다면 메모리 용량 제한으로 문제를 풀 수 없을 수도 있다. (드뭄) 채점환경 # 일반적으로 시간제한 및 메모리 제한 정보가 적혀있음. python3.7 기준으로 1초에 2,000만번의 연산을 수행한다고 가정하면 큰 무리 없음 시간제한이 1초이고, 데이터 개수가 100만개인 문제가 있다면 시간 복잡도 $O(Nlog_2 N)$ 내에 풀어야 한다. ($log_2 1,000,000$) 시간 제한과 데이터의 개수를 먼저 확인하고, 어느 정도의 시간복잡도 알고리즘을 작성해야할지 예측할 수 있어야 한다. 문제 # 상하좌우 게임개발 시각 왕실의나이트 "},{"id":41,"href":"/docs/mystudy/algorithm-note/part2/5_dfs_bfs/","title":"5. DFS \u0026 BFS","section":"Part 2","content":"자료구조 기초\nDFS # DFS란? # Depth-First Search의 약자로, 깊이 우선 탐색 그래프(트리)에서 깊은 부분을 우선적으로 탐색하는 알고리즘 특정한 경로로 탐색하다가 특정한 상황에서 최대한 깊숙이 들어가서 노드를 방문한 후, 다시 돌아가 다른 경로로 탐색하는 알고리즘 DFS는 스택 자료구조를 이용하며 구체적인 동작 과정은 다음과 같다 탐색 시작 노드를 스택에 삽입하고, 방문 처리한다. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고, 방문 처리를 한다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다. 2번의 과정을 더 이상 수행할 수 없을 때까지 반복한다. 방문 처리 : 스택에 한 번 삽입되어 처리된 노드가 다시 삽입되지 않게 체크하는 것. 방문처리를 함으로써 각 노드를 한 번씩만 처리한다. 스택 자료구조에 기초해 구현이 간단함. 실제로는 스택을 쓰지 않아도 됨. N개의 데이터가 있을 때, $O(N)$의 시간이 소요됨 재귀함수를 이용했을 때 매우 간결하게 구현할 수 있음. 구현 코드 # 방법1 재귀함수와 List 그래프를 사용하여 구현한 방법\ndef dfs(graph:list, v:int, visited:list): visited[v] = True print(v, end=\u0026#39; \u0026#39;) for i in graph[v]: if not visited[i]: dfs(graph, i, visited) # 사용 예시 graph = [ [], [2, 3, 8], [1, 7], [1, 4, 5], [3, 5], [3, 4], [7], [2, 6, 8], [1, 7] ] visited = [False] * 9 dfs(graph, 1, visited) 방법2 재귀함수와 Dict 그래프를 사용하여 구현한 방법\ndef dfs(g:dict, curr_node:int or str, visited:set=None): \u0026#34;\u0026#34;\u0026#34; Parameters ---------- graph: dictionary dictionary of nodes and its neighbors node: list Returns ------- visited: set a set of visited graph nodes Algo: add current node to the list of visited \u0026#34;\u0026#34;\u0026#34; if visited is None: visited = set() visited.add(curr_node) print(\u0026#34;added %d\u0026#34; % curr_node) for neigh_node in g[curr_node]: if neigh_node not in visited: dfs(g, neigh_node, visited) return visited BFS # BFS란? # Breadth First Search의 약자로, 너비 우선 탐색 DFS가 최대한 멀리 있는 노드를 우선으로 탐색하는 방식이었다면, BFS는 가까운 노드부터 탐색하는 알고리즘 BFS는 큐 자료구조를 이용해서 구현하는 것이 정석 인접한 노드를 반복적으로 큐에 넣도록 알고리즘을 작성하면 자연스럽게 먼저 들어온 것이 먼저 나가게 되어 가까운 노드부터 탐색하게 됨 동작 방식 탐색 시작 노드를 큐에 삽입 후, 방문 처리 큐에서 노드를 꺼내 해당 노드의 인접 노드 중 방문하지 않은 노드를 큐에 삽입하고, 방문 처리 2번의 과정을 더 이상 수행할 수 없을 때까지 반복 큐 자료구조에 기초한다는 점에서 구현이 간단, deque 라이브러리를 사용하는 것이 좋음 N개의 데이터에 대해, $O(N)$의 시간이 소요됨. 일반적인 경우 실제 수행시간은 DFS보다 좋은 편이다. 왜냐하면, DFS를 재귀함수로 구현하면서 컴퓨터 시스템의 동작 특성상 실제 프로그램 수행시간은 느려진다. 스택 라이브러리를 이용해 시간 복잡도를 완화하는 테크닉이 필요하기도 하다. 구현 코드 # 방법1 from collections import deque def bfs(graph:list, start:int, visited:list): queue = deque([start]) visited[start] = True while queue: v = queue.popleft() for i in graph[v]: print(v, end=\u0026#39; \u0026#39;) if not visited[i]: queue.append(i) visited[i] = True # 사용 예시 graph = [ [], [2, 3, 8], [1, 7], [1, 4, 5], [3, 5], [3, 4], [7], [2, 6, 8], [1, 7] ] visited = [False] * 9 bfs(graph, 1, visited) 방법2 from collections import deque def bfs(graph:dict, start_node:int or str): visited = set() queue = deque([start_node]) while queue: node = queue.popleft() if node not in visited: visited.add(node) queue.extend(graph[node]) return visited 방법3 level(distance)도 얻어야 할 때 사용하는 방법\n혹은 특정 level(거리)까지만 탐색하면 될 때\nfrom collections import deque def bfs(graph:dict, start_node:int or str): visited = set() queue = deque([start_node]) dist = deque([0]) while queue: node = queue.popleft() d = dist.popleft() if node not in visited: visited.add(node) queue.extend(graph[node]) dist.extend([d+1 for _ in range(len(graph[node]))]) return visited 방법4 level(distance)도 얻어야 할 때 사용하는 방법\n혹은 특정 level(거리)까지만 탐색하며, 방문 노드들에 대해 level을 알아야 할 때\nfrom collections import deque, defaultdict def nodes_by_level(graph:dict, curr_node:int): lv_to_n = defaultdict(set) n_to_lv = defaultdict(lambda:-1) visited = set() queue = deque([curr_node]) next_queue = deque() lv = 0 while queue: visited.update(queue) lv_to_n[lv].update(queue) for node in queue: n_to_lv[node] = lv next_queue.extend(graph[node].difference(visited)) lv += 1 queue, next_queue = next_queue, deque() return lv_to_n, n_to_lv 요약 # DFS BFS 동작 원리 스택 큐 구현 방법 재귀 함수 큐 자료구조 문제 # 미로탈출 음료수 얼려 먹기 "},{"id":42,"href":"/docs/mystudy/algorithm-note/part2/6_%EC%A0%95%EB%A0%AC/","title":"6. 정렬","section":"Part 2","content":" 정렬 # 데이터를 특정한 기준에 따라 나열하는 것 프로그램 작성할 때 가장 많이 사용되는 알고리즘 이진탐색의 전처리 과정이기도 함 알고리즘의 효율성을 쉽게 이해할 수 있음 일반적으로 문제에서 요구하는 조건에 따라 적절한 정렬 알고리즘이 공식처럼 사용된다. 정렬 알고리즘의 종류 # 선택 정렬 삽입 정렬 퀵 정렬 계수 정렬 파이썬의 기본 정렬 라이브러리로 더 효과적인 정렬 하기 # 정렬 알고리즘은 이 밖에도 매우 다양한 종류가 있음. 정렬 알고리즘을 직접 작성하게 되는 경우도 있지만, 미리 만들어진 라이브러리를 이용하는 것이 효과적인 경우가 더 많다. 파이썬의 기본 정렬 라이브러리인 sorted()는 퀵 정렬과 동작 방식이 비슷한 병합 정렬을 기반으로 만들어졌다. 병합 정렬은 일반적으로는 퀵 정렬보다 느리지만 최악의 경우에도 시간복잡도 $O(NlogN)$을 보장한다. 문제 # 성적이낮은순서로 위에서아래로 "},{"id":43,"href":"/docs/mystudy/algorithm-note/part2/7_%EC%9D%B4%EC%A7%84%ED%83%90%EC%83%89/","title":"7. 이진탐색","section":"Part 2","content":" 이진탐색 # 1. 범위를 반씩 좁혀가는 탐색 # 순차탐색 # N개의 데이터가 있을 때, 그 데이터를 하나씩 확인하며 어떠한 처리를 해준 것이 순차 탐색 그자체 순차 탐색이란 리스트 안에 있는 특정한 데이터를 찾기 위해 앞에서부터 데이터를 하나씩 차례대로 확인하는 방법 보통 정렬되지 않은 리스트에서 데이터를 찾아야 할 때 사용한다. 순차 탐색은 리스트에 특정 값의 원소가 있는지 체크할 때도 쓰며, 리스트 자료형에서 특정한 원소의 개수를 세는 count() 메서드를 사용할 때도 쓰인다. 순차탐색의 최악의 경우 시간복잡도는 $O(N)$ 이진 탐색 # 데이터가 정렬되어 있어야만 사용할 수 있음. 이미 정렬되어 있다면, 매우 빠르게 데이터를 찾을 수 있다는 장점 탐색 범위를 절반씩 좁혀가며 탐색 이진 탐색은 위치를 나타내는 변수 3개를 사용. 탐색하고자 하는 범위의 시작점, 끝점, 중간점. 찾으려는 데이터와 중간점 위치에 있는 데이터를 반복적으로 비교해서 원하는 데이터를 찾는 것. 이진 탐색의 시간 복잡도는 한 번 확인할 때마다 원소의 개수가 절반씩 줄어든다는 점에서 $O(logN)$이다. 이진탐색을 구현하는 2가지 방법. 재귀 함수 이용, 반복문 이용 반복문을 사용한 이진탐색 소스코드\ndef binary_search(arr, target): s, e = 0, len(arr)-1 m = (s+e)//2 while arr[m]!=target: if s \u0026gt; e: return -1 if target \u0026lt; arr[m]: e = m-1 m = (s+e)//2 else: s = m+1 m = (s+e)//2 return m 재귀함수 소스코드\n# SOLUTION def binary_search(arr, target, s, e): if e \u0026lt; s: return -1 m = (s+e)//2 if arr[m] \u0026lt; target: return binary_search(arr, target, m+1, e) elif arr[m] \u0026gt; target: return binary_search(arr, target, s, m-1) else: return arr[m] # TEST N = 10 arr = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19] target = 7 print(binary_search(arr, target, 0, N-1)) 이진탐색을 쓸 수 있는 조건 # 단조 증가 함수 / 정렬되어 있을 때 코딩테스트에서 이진탐색 # 제대로 이진 탐색 코드를 작성한 프로그래머는 10% 내외라 할 정도로 까다로운 구현 코딩테스트에서 단골로 나오는 문제 이진 탐색의 원리는 다른 알고리즘에서도 폭넓게 적용되는 원리와 유사 높은 난이도의 문제에서는 이진탐색 알고리즘과 다른 알고리즘과 함께 사용되기도 함. 탐색 범위가 큰 상황에서 많이 쓰임. 탐색범위가 2,000만을 넘어가면 이진 탐색으로 접근해보기 처리해야할 데이터의 개수나 값이 1,000만 단위 이상으로 넘어가면 이진 탐색과 같이 $O(logN)$ 의 속도를 내야 하는 알고리즘을 떠올려야 한다. 트리 자료구조 # 이진 탐색의 전제 조건은 \u0026ldquo;정렬\u0026rdquo; 데이터베이스는 내부적으로 대용량 데이터 처리에 적합한 트리 자료구조를 이용하여 항상 데이터가 정령되어 있다. 데이터베이스에서는 이진 탐색과는 조금 다르지만, 이진 탐색과 유사한 방법을 이용해 탐색을 항상 빠르게 수행하도록 설계되어 있어 데이터가 많아도 탐색 속도가 빠름 트리 자료구조란? 노드와 노드의 연결로 표현 노드 : 어떤 정보의 단위로서 어떠한 정보를 가지고 있는 개체 트리 자료구조는 그래프 자료구조의 일종으로 데이터베이스 시스템이나 파일 시스템과 같은 곳에서 많은 양의 데이터를 관리하기 위한 목적으로 사용 트리 자료구조의 특징 트리는 부모 노드와 자식 노드의 관계로 표현됨 트리의 최상단 노드를 루트 노드라고 함 트리의 최하단 노드를 단말 노드라고 함 트리에서 일부를 떼어내도 트리 구조이며, 이를 서브 트리라 함 트리는 파일 시스템과 같이 계층적이고 정렬된 데이터를 다루기에 적합 =\u0026gt; 큰 데이터를 처리하는 소프트웨어는 대부분 데이터를 트리 자료구조로 저장해 이진 탐색과 같은 탐색 기법을 이용해 빠르게 탐색한다. 이진 탐색 트리 # 트리 자료구조 중에서 가장 간단한 형태 이진 탐색이 동작할 수 있도록 고안된 효율적인 탐색이 가능한 자료구조 모든 트리가 다 이진 탐색 트리는 아니다. 이진 탐색 트리의 특징 부모 노드보다 왼쪽 자식 노드가 작다. 부모 노드보다 오른쪽 자식 노드가 크다. 문제 # 떡볶이떡만들기 부품찾기 징검다리건너기 "},{"id":44,"href":"/docs/mystudy/algorithm-note/part2/8_%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/","title":"8. DP","section":"Part 2","content":" 다이나믹 프로그래밍 # 중복되는 연산을 줄이자 # 최적의 해를 구하기에 시간이 매우 많이 필요하거나 메모리 공간이 매우 많이 필요한문제는 컴퓨터로도 해결하기 어렵다. 연산 속도와 메모리 공간을 최대한으로 활용할 수 있는 효율적인 알고리즘 작성 필요 메모리 공간을 약간 더 사용하면서 연산 속도를 비약적으로 증가시키는 대표적인 방법 Dynamic Programming 동적 계획법이라고 표현하기도 한다. 다이나믹 프로그래밍으로 해결할 수 있는 대표적인 예시: 피보나치 수열 ** 파이썬의 경우 기본 자료형인 리스트 자료형이 연결 리스트 기능을 포함하고 있음.\n심각한 시간 복잡도를 발생시키는 재귀함수 # 재귀함수로 구현한 피보나치 함수\ndef fibo(x): if x==1 or x==2: return 1 return fibo(x-1) + fibo(x-2) 위와 같이 피보나치 수열의 소스코드를 짜면 시간복잡도가 $O(2^N)$ N=30 이면 약 10억 가량의 연산 수행 필요 동일한 함수가 반복적으로 호출되며 불필요한 연산 발생 이러한 문제를 다이나믹 프로그래밍으로 효율적으로 해결 다이나믹 프로그래밍을 사용할 수 있는 조건 # 큰 문제를 작은 문제로 나눌 수 있다. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다. 메모제이션(Memoization) 기법 # 다이나믹 프로그래밍 구현할 수 있는 기법 중 하나 한 번 구한 결과를 메모리 공간에 메모해 두고 다시 호출 메모한 결과를 그대로 가져오는 기법 값을 저장하는 방법이므로 캐싱(Caching)이라고도 함 메모제이션 기법을 사용한 피보나치 수열\nd = [0] * 100 def fibo(x): if x==1 or x==2: return 1 if d[x]!=0: return d[x] d[x] = fibo(x-1) + fibo(x-2) return d[x] 반복문을 사용한 DP # 재귀 함수를 사용하면 함수를 다시 호출했을 때, 메모리 상에 적재되는 일련의 과정을 따라야 하기 때문에 오버헤드가 발생할 수도 있다. 일반적으로 반복문을 이용한 DP가 더 성능이 좋다. DP를 적용했을 때 피보나치 수열 알고리즘의 시간복잡도? $O(N)$ 재귀 함수를 이용한 DP는 **Top-Down 방식(하향식)**이며, 반복문을 이용한 DP는 Bottom-Up 방식(상향식) 결론 # 가능하다면 탑다운 보다는 보텀업 방식 권장 재귀함수는 스택의 크기가 한정되어 있을 수도 있기 때문 문제 # 1로만들기\n개미전사\n바닥공사\n효율적인 화폐구성\n"},{"id":45,"href":"/docs/mystudy/algorithm-note/part2/9_%EC%B5%9C%EB%8B%A8%EA%B2%BD%EB%A1%9C/","title":"9. 최단경로","section":"Part 2","content":" 최단 경로 # 가장 짧은 경로를 찾는 알고리즘, \u0026ldquo;길찾기\u0026rdquo; 문제라고도 불림. 최단 경로 알고리즘 유형에도 다양한 종류가 있음. 예를 들어 \u0026lsquo;한 지점에서 다른 특정 지점까지의 최단 경로 구하기\u0026rsquo; 또는 \u0026lsquo;모든 지점에서 다른 모든 지점까지의 최단 경로 구하기\u0026rsquo; 등.. 최단 경로 문제는 보통 그래프를 이용해 표현하며, 그래프는 \u0026ldquo;노드\u0026quot;와 \u0026ldquo;간선\u0026quot;으로 구성된다. 최단 거리 알고리즘 # 다익스트라 최단 경로 플로이드 워셜 벨만 포드 알고리즘 (최단 거리 알고리즘은 그리디, 다이나믹 프로그래밍 알고리즘의 한 유형이다.)\n다익스트라 최단 경로 # 특정한 노드에서 출발하여 다른 노드로 가는 각각의 최단 경로를 구해주는 알고리즘 \u0026lsquo;음의 간선\u0026rsquo;이 없을 때 정상적으로 동작됨\n(\u0026lsquo;음의 간선\u0026rsquo;: 0보다 작은 값을 가지는 간선) 현실세계의 길은 음의 간선으로 표현되지 않기 때문에 실제로 GPS 소프트웨어 기본 알고리즘으로 채택됨 그리디 알고리즘으로 분류 다익스트라 최단 경로의 순서 # 출발 노드 설정 최단 거리 테이블 초기화 방문하지 않은 노드 중 최단거리가 가장 짧은 노드 선택 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블 갱신 3,4번을 반복 다익스트라 최단 경로의 특징 # 최단 경로를 구하는 과정에서 \u0026lsquo;각 노드에 대한 현재까지의 최단 거리\u0026rsquo; 정보를 항상 1차원 리스트에 저장하며 리스트를 계속 갱신 매번 현재 처리하고 있는 노드를 기준으로 주변 간선 확인 데이크스트라와 같은 알고리즘 방문하지 않은 노드 중에서 가장 최단 거리가 짧은 노드를 선택하는 과정을 반복 위 과정에서 선택된 노드는 \u0026lsquo;최단거리\u0026rsquo;가 완전히 선택된 노드이므로, 더 이상 알고리즘을 반복해도 최단 거리가 줄어들지 않는다. (\u0026raquo;정말?) \u0026gt;\u0026gt;한 단계당 하나의 노드에 대한 최단 거리를 확실히 찾는 것으로 이해할 수 있음. \u0026gt; 그렇기 때문에 사실 마지막 노드에 대해서는 해당 노드를 거쳐 다른 노드로 가는 경우를 확인할 필요가 없다. 다익스트라 소스코드\nINF = int(1e9) def Dijkstra(g, N, start): distance = [0] + [INF] * (N-1) not_visited = {i for i in range(N)} while not_visited: # 최단거리가 가장 짧은 노드 선택 v = -1 mind = INF for nv in not_visited: if distance[nv] \u0026lt; mind: v = nv mind = distance[nv] not_visited.remove(v) # 최단거리 테이블 갱신 for i,d in enumerate(g[v]): if (d != -1) and (mind + d \u0026lt; distance[i]): distance[i] = mind + d return distance # TEST N = 6 g = [ [0, 2, 5, 1, -1, -1], [-1, 0, 3, 2, -1, -1], [-1, 3, 0, -1, -1, 5], [-1, -1, 3, 0, 1, -1], [-1, -1, 1, -1, 0, 2], [-1, -1, -1, -1, -1, 0] ] print(Dijkstra(g, N, 1)) "},{"id":46,"href":"/docs/memo/commands/git/clone/","title":"clone 관련","section":"Git 관련","content":" 클론 # git clone {REPO_URL} {DIR_생략가능} "},{"id":47,"href":"/docs/memo/commands/git/cancel/","title":"commit 취소","section":"Git 관련","content":" commit 취소 # # 꺽쇠 수만큼 전으로 돌아감 git reset HEAD^ git reset HEAD^^ # 숫자만큼 전으로 돌아감 git reset HEAD~1 git reset HEAD~2 commit 취소 - push 했을 때 # git reset HEAD^ # 원하는 시점으로 되돌리기 git reflog git reset {commit id} # 강제 푸시 git push origin {branch name} -f "},{"id":48,"href":"/docs/memo/commands/git/credential/","title":"credential 관련","section":"Git 관련","content":" Credential 정보를 반영구 저장 # git config credential.helper store "},{"id":49,"href":"/docs/memo/commands/git/","title":"Git 관련","section":"자주 쓰는 명령어들","content":" clone 관련 클론 # git clone {REPO_URL} {DIR_생략가능} commit 취소 commit 취소 # # 꺽쇠 수만큼 전으로 돌아감 git reset HEAD^ git reset HEAD^^ # 숫자만큼 전으로 돌아감 git reset HEAD~1 git reset HEAD~2 commit 취소 - push 했을 때 # git reset HEAD^ # 원하는 시점으로 되돌리기 git reflog git reset {commit id} # 강제 푸시 git push origin {branch name} -f credential 관련 Credential 정보를 반영구 저장 # git config credential.helper store 서브모듈 관련 ref - git doc 서브모듈 추가 # git submodule add {저장소 URL} 서브모듈 끊기 # # 1. 모듈 deinit git submodule deinit -f {모듈명} # 2. .git/modules 에서 폴더 삭제 rm -rf .git/modules/{모듈명} # 3. git에서 해당 폴더를 제거 git rm -f {모듈명} 서브모듈까지 모두 clone # git clone --recursive {저장소 URL} 또는 git clone {저장소 URL} git submodule update --init --recursive 서브모듈까지 모두 업데이트(pull) # # 모든 서브모듈에 대해 동일한 명령어를 수행하고 싶을 때 git submodule foreach [명령어] # 모든 서브모듈에 대해 git pull git submodule foreach git pull origin master 또는 초기설정 관련 모든 설정값 확인 # git config --list 특정값 확인 git config user.name 모든 설정값과 해당 위치 확인 # git config --list --show-origin 사용자 이름 및 이메일 설정 # git config --global user.name \u0026#34;\u0026lt;사용자ID\u0026gt;\u0026#34; git config --global user.email {이메일} * global 옵션을 전달할 경우 한번만 수행해도 된다. 설정값 지우기 # git config --unset user.name git config --unset user.email git config --unset --global user.name git config --unset --global user.email * global로 설정한 경우, global로 지워야 한다. "},{"id":50,"href":"/docs/memo/commands/linux/gpu/","title":"GPU 관련","section":"Linux","content":" GPU 스펙 확인 # nvidia-smi 사용용량 확인 # nvidia-smi "},{"id":51,"href":"/docs/mystudy/hugo-blog/","title":"Hugo로 github 블로그 만들기","section":"My Study","content":" 셋팅 및 시작 Intro # Ref # https://github.com/Integerous/Integerous.github.io https://ialy1595.github.io/post/blog-construct-1/ How to # 1. Hugo 설치 # hugo 공식깃헙에서 다운로드 윈도우를 사용하고, 추가 기능이 필요할지 몰라 extended 버전인 hugo_extended_0.121.0_windows-amd64을 받았다. C:\\Hugo\\bin 디렉토리 생성해서 다운받은 압축파일 해제 환경변수에 Hugo 영구적으로 추가 $ setx PATH=%PATH%C:\\Hugo\\bin; hugo 실행 확인 hugo version 또는 hugo help 명령어 2. Gihub 레포 셋팅 # Blog 저장소 Private으로 생성 (저장소명 다르게해도 됨) \u0026lt;USERNAME\u0026gt;.github.io 저장소 생성 Blog 레포를 로컬에 clone한다. git clone https://github. 컨텐츠 연결 git 서브모듈 사용하여 컨텐츠 연결 # 나는 기존에 깃헙레포를 노트처럼 사용하면서 공부한 내용들을 적어두고 있었다 그래서 그 레포를 블로그에 연결하고자 submodule을 사용했다. 1. 컨텐츠 디렉토리로 이동 # cd content/docs 2. 저장소 submodule로 추가 # git submodule add {저장소의 URL} 3. 변경내용 add, commit, push # cd Blog/ git add . git commit -m \u0026#34;{커밋메시지}\u0026#34; git push 자동 업로드 Github Action을 사용하여 컨텐츠 업로드 자동화하기 # ref # 코드인용 action 공부 https://somaz.tistory.com/213#google_vignette https://fe-developers.kakaoent.com/2022/220106-github-actions/ https://velog.io/@adam2/Github-Action-%EC%A3%BC%EC%9A%94-%EB%AC%B8%EB%B2%95 https://kotlinworld.com/400 1. 토큰 발급 # https://github.com 에서 우측 상단 프로필 클릭 Settings 클릭 좌측 바 하단의 Developer Settings 클릭 Personal access tockens 클릭 Generate new token 클릭 블로그 관련 모든 레포에 대한 권한을 부여한 토큰 생성 토큰 복사 2. Secret 등록 # github에서 Blog 저장소 접속 상단 바에서 Settings 클릭 좌측 네비게이션 바에서 Secrets and variables \u0026gt; Actions 클릭 New repository secret 클릭 NAME은 TOKEN으로 Secret에는 복사한 토큰을 붙여넣기 하여 등록 서브모듈 저장소들에도 위와 같은 방법으로 Secret 등록 2. "},{"id":52,"href":"/docs/mystudy/algorithm-note/part2/","title":"Part 2","section":"Algorithm Note","content":" 3. 그리디 알고리즘 Greedy # 단순하지만 강력한 문제 해결 방법 현재 상황에서 지금 당장 좋은 것만 고르는 방법 현재의 선택이 나중에 미칠 영향에 대해서는 고려하지 않음 다익스트라 알고리즘은 엄밀히 말하면 Greedy 알고리즘 보통 코딩테스트에서 출제되는 Greedy 알고리즘 유형의 문제는 창의력, 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구 Greedy 알고리즘의 정당성 # greedy 알고리즘을 모든 문제에 적용할 수 있는 것은 아니다. Greedy로 정확한 답을 찾을 수 있다는 보장이 있을 때는 매우 효과적이고 직관적 4. 구현 Implementation # 구현? 머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정 어떤 문제를 풀든 소스코드를 작성하는 과정은 필수이기 때문에 구현 문제는 모든 범위의 문제 유형을 포함한다. 취업 코딩테스트에서는 자주 출제됨 문제에 대한 정확한 풀이 방법이 떠오르면, 프로그래밍 언어로 정확히 구현해내야 함. 프로그래밍 언어의 문법을 정확히 알고 있어야 하며, 문제의 요구사항에 어긋나지 않는 답안 코드를 작성해야함 구현 유형 문제 : 풀이를 떠올리는 것은 쉽지만, 소스코드로 옮기기 어려운 문제 흔히 개발할 때 프로그래밍 언어의 문법에 능숙하고 코드 작성속도가 빠른 사람을 보고 \u0026ldquo;피지컬이 좋다\u0026quot;고 한다. 5. DFS \u0026amp; BFS 자료구조 기초 DFS # DFS란? # Depth-First Search의 약자로, 깊이 우선 탐색 그래프(트리)에서 깊은 부분을 우선적으로 탐색하는 알고리즘 특정한 경로로 탐색하다가 특정한 상황에서 최대한 깊숙이 들어가서 노드를 방문한 후, 다시 돌아가 다른 경로로 탐색하는 알고리즘 DFS는 스택 자료구조를 이용하며 구체적인 동작 과정은 다음과 같다 탐색 시작 노드를 스택에 삽입하고, 방문 처리한다. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고, 방문 처리를 한다. 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼낸다. 6. 정렬 정렬 # 데이터를 특정한 기준에 따라 나열하는 것 프로그램 작성할 때 가장 많이 사용되는 알고리즘 이진탐색의 전처리 과정이기도 함 알고리즘의 효율성을 쉽게 이해할 수 있음 일반적으로 문제에서 요구하는 조건에 따라 적절한 정렬 알고리즘이 공식처럼 사용된다. 정렬 알고리즘의 종류 # 선택 정렬 삽입 정렬 퀵 정렬 계수 정렬 파이썬의 기본 정렬 라이브러리로 더 효과적인 정렬 하기 # 정렬 알고리즘은 이 밖에도 매우 다양한 종류가 있음. 정렬 알고리즘을 직접 작성하게 되는 경우도 있지만, 미리 만들어진 라이브러리를 이용하는 것이 효과적인 경우가 더 많다. 7. 이진탐색 이진탐색 # 1. 범위를 반씩 좁혀가는 탐색 # 순차탐색 # N개의 데이터가 있을 때, 그 데이터를 하나씩 확인하며 어떠한 처리를 해준 것이 순차 탐색 그자체 순차 탐색이란 리스트 안에 있는 특정한 데이터를 찾기 위해 앞에서부터 데이터를 하나씩 차례대로 확인하는 방법 보통 정렬되지 않은 리스트에서 데이터를 찾아야 할 때 사용한다. 순차 탐색은 리스트에 특정 값의 원소가 있는지 체크할 때도 쓰며, 리스트 자료형에서 특정한 원소의 개수를 세는 count() 메서드를 사용할 때도 쓰인다. 8. DP 다이나믹 프로그래밍 # 중복되는 연산을 줄이자 # 최적의 해를 구하기에 시간이 매우 많이 필요하거나 메모리 공간이 매우 많이 필요한문제는 컴퓨터로도 해결하기 어렵다. 연산 속도와 메모리 공간을 최대한으로 활용할 수 있는 효율적인 알고리즘 작성 필요 메모리 공간을 약간 더 사용하면서 연산 속도를 비약적으로 증가시키는 대표적인 방법 Dynamic Programming 동적 계획법이라고 표현하기도 한다. 다이나믹 프로그래밍으로 해결할 수 있는 대표적인 예시: 피보나치 수열 ** 파이썬의 경우 기본 자료형인 리스트 자료형이 연결 리스트 기능을 포함하고 있음. 9. 최단경로 최단 경로 # 가장 짧은 경로를 찾는 알고리즘, \u0026ldquo;길찾기\u0026rdquo; 문제라고도 불림. 최단 경로 알고리즘 유형에도 다양한 종류가 있음. 예를 들어 \u0026lsquo;한 지점에서 다른 특정 지점까지의 최단 경로 구하기\u0026rsquo; 또는 \u0026lsquo;모든 지점에서 다른 모든 지점까지의 최단 경로 구하기\u0026rsquo; 등.. 최단 경로 문제는 보통 그래프를 이용해 표현하며, 그래프는 \u0026ldquo;노드\u0026quot;와 \u0026ldquo;간선\u0026quot;으로 구성된다. 최단 거리 알고리즘 # 다익스트라 최단 경로 플로이드 워셜 벨만 포드 알고리즘 (최단 거리 알고리즘은 그리디, 다이나믹 프로그래밍 알고리즘의 한 유형이다. "},{"id":53,"href":"/docs/mystudy/algorithm-note/part3/","title":"Part 3","section":"Algorithm Note","content":" 그리디 알고리즘 "},{"id":54,"href":"/docs/memo/commands/poetry/poetry_start/","title":"Poetry 시작하기","section":"Poetry","content":" poetry 설치 (Windows) # pip으로 설치\npip install --user poetry powershell에서 아래 명령어로 설치\n(Invoke-WebRequest -Uri https://install.python-poetry.org -UseBasicParsing).Content | py - poetry 환경변수 등록 # windows\nC:\\Users\\SEJONG\\AppData\\Roaming\\Python\\Scripts\\ 또는 C:\\Users\\SEJONG\\AppData\\Roaming\\Python\\Python311\\Scripts\\ 또는 C:\\Users\\SEJONG\\AppData\\Roaming\\pypoetry\\venv\\Scripts\\ 에 poetry 가 있는지 확인 poetry가 있는 주소를 환경변수에 등록 poetry 시작 # poetry init 각 입력사항에 맞게 입력하면, pyproject.toml 생성됨\npoetry config # # poetry 설정값 확인 poetry config --list # 프로젝트 폴더 내에 가상환경을 저장 poetry config virtualenvs.in-project true poetry 의존성 추가 # poetry add \u0026#34;\u0026lt;패키지\u0026gt;\u0026lt;버전표기\u0026gt;\u0026#34; # 예 poetry add \u0026#34;selenium^4.10.0\u0026#34; # 가장 최신 버전 설치할 때 poetry add {패키지}@latest 스크립트 실행 # poetry run python {실행파일} Ref # https://python-poetry.org/docs/cli/\n"},{"id":55,"href":"/docs/memo/commands/etc/python-parameter/","title":"python 실행파일 인자값 받기","section":"Etc","content":" python 실행파일 인자값 받기 # 1. sys.argv # test.py 가 아래와 같은 파일이고, import sys print(sys.argv) 아래 명령어를 실행하면, $ python test.py abc hello name 출력은 아래와 같다. [\u0026#39;test.py\u0026#39;, \u0026#39;abc\u0026#39;, \u0026#39;hello\u0026#39;, \u0026#39;name\u0026#39;] sys.argv는 리스트이고, [0]은 무조건 실행파일명, 그 다움 순서대로 입력받은 인자값이 리스트에 들어감 2. configparser # 아래와 같이 Section, Key, Value 값의 형태로 설정된 설정 파일을 사용 config file (확장자 .cfg) [SectionOne] # Section - 대괄호 Status: Single # 속성 - Key : Value Name: Derek Value: Yes Age: 30 [SectionTwo] FavoriteColor = Green # :(콜론)을 써도 되고, =(equal)을 써도 된다. [SectionThree] FamilyName: Johnson 위 파일을 읽어들여 사용하는 아래 파일을 실행시키면 됨 import configparser config = configparser.ConfigParser() config.sections() # 빈 List config.read(\u0026#39;example.cfg\u0026#39;) config.sections() # Section Name들 List for sec in config.sections(): print(f\u0026#39;---{sec}---\u0026#39;) for key in config[sec]: value = config[sec][key] print(\u0026#39;{0} : {1}\u0026#39;.format(key, value)) 3. argparse # args_test.py 가 아래와 같은 파일일 때, import argparse def parse_args(): parser = argparse.ArgumentParser(description=\u0026#39;ArgumentParser Tutorial\u0026#39;) parser.add_argument(\u0026#39;a\u0026#39;, help=\u0026#39;parameter description\u0026#39;) group_gpus.add_argument(\u0026#34;-b\u0026#34;, \u0026#34;--bparam\u0026#34;, type=int, default=0, help=\u0026#39;b parameter description\u0026#39;) args = parser.parse_args() return args def main(): args = parse_args() print(args.a) print(args.bparam) if __name__ == \u0026#34;__main__\u0026#34;: main() 아래와 같은 명령어를 실행하면 $ python args_test.py \u0026#34;hello\u0026#34; -b \u0026#34;world\u0026#34; 아래와 같이 출력됨 hello world ref\n"},{"id":56,"href":"/docs/memo/commands/etc/python-venv/","title":"python3 venv 사용법","section":"Etc","content":" venv # python2에서는 써드파티 라이브러리인 virtualenv 가상환경 라이브러리를 사용\npython3에서는 기본적으로 제공되는 venv 가상환경 라이브러리를 사용\n가상환경 생성 # python -m venv {가상환경이름} 가상환경 활성화 # {가상환경이름}\\Scripts\\activate.bat 가상환경 삭제 # 가상환경 이름의 폴더를 휴지통으로 이동 (삭제)\n"},{"id":57,"href":"/docs/memo/commands/etc/python-server/","title":"python3 서버열기","section":"Etc","content":" python 으로 http 서버 열기 # $ python3 -m http.server \u0026lt;포트번호 ex.8000\u0026gt; "},{"id":58,"href":"/docs/memo/commands/linux/screen/","title":"Ubuntu Screen 명령어","section":"Linux","content":" screen tool 설치 # sudo apt-get install screen screen 생성 # screen -S \u0026lt;생성할 스크린 이름\u0026gt; screen 나가기 # ctrl + a + d (단축키) screen 리스트 확인 # screen -ls 생성된 screen에 재접속 # screen -R \u0026lt;접속할 스크린 이름\u0026gt; "},{"id":59,"href":"/docs/memo/commands/etc/vscode_shortcuts/","title":"VSCode 단축키","section":"Etc","content":" 내가 자주 쓰는 VSCode 단축키 # 설명 단축키 코드 전체 접기 Ctrl + k + 0 코드 전체 펼치기 Ctrl + k + j "},{"id":60,"href":"/docs/memo/commands/conda/virtual_env/","title":"가상환경 관련","section":"Conda","content":" 가상환경 생성 # conda create -n \u0026lt;가상환경명\u0026gt; conda create -n \u0026lt;가상환경명\u0026gt; python=3.7 conda create -n \u0026lt;가상환경명\u0026gt; --clone \u0026lt;가상환경명\u0026gt; 가상환경 목록 # conda env list conda info envs 가상환경에 jupyter kernel 연결 # python -m ipykernel install --user --name \u0026lt;가상환경명\u0026gt; --display-name \u0026lt;커널명\u0026gt; 가상환경 삭제 # conda remove --name {가상환경명} --all 가상환경 활성화 # conda activate {가상환경명} 가상환경 비활성화 # conda deactivate "},{"id":61,"href":"/docs/memo/commands/poetry/virtual_env/","title":"가상환경 관련","section":"Poetry","content":" 가상환경 비활성화 # deactivate exit poetry 가상환경 확인 # poetry env list 프로젝트 폴더 내에 가상환경을 저장 # poetry config virtualenvs.in-project true 가상환경 모두 삭제 # poetry env remove --all poetry 로 가상환경(virtualenv)을 관리 # poetry env use {파이썬경로} "},{"id":62,"href":"/docs/memo/freq-used-code/histogram/","title":"간단한 히스토그램 python","section":"자주 쓰는 코드들","content":"import matplotlib.pyplot as plt plt.hist(data, bins=bin_num) import matplotlib.pyplot as plt import numpy as np cnts, bins = np.histogram(data, bin_num) plt.his(data, bins) "},{"id":63,"href":"/docs/memo/freq-used-code/warnings/","title":"경고 무시 python","section":"자주 쓰는 코드들","content":" python 경고 무시하기 # import warnings warnings.filterwarnings(action=\u0026#39;ignore\u0026#39;) "},{"id":64,"href":"/docs/memo/commands/poetry/export/","title":"내보내기 (requirements.txt)","section":"Poetry","content":" poetry 환경 requirements.txt로 내보내기 # # 기본 활용 방식 poetry export -f requirements.txt --output requirements.txt # 해시 정보 없이 export 하기 poetry export -f requirements.txt --output requirements.txt --without-hashes "},{"id":65,"href":"/docs/memo/commands/linux/background/","title":"백그라운드 관련","section":"Linux","content":" 백그라운드 프로세스 목록 # jobs 출력\n[job 번호]job기호 job상태 백그라운드 프로세스 종료 # kill %\u0026lt;job 번호\u0026gt; "},{"id":66,"href":"/docs/memo/commands/git/submodule/","title":"서브모듈 관련","section":"Git 관련","content":"ref - git doc\n서브모듈 추가 # git submodule add {저장소 URL} 서브모듈 끊기 # # 1. 모듈 deinit git submodule deinit -f {모듈명} # 2. .git/modules 에서 폴더 삭제 rm -rf .git/modules/{모듈명} # 3. git에서 해당 폴더를 제거 git rm -f {모듈명} 서브모듈까지 모두 clone # git clone --recursive {저장소 URL} 또는\ngit clone {저장소 URL} git submodule update --init --recursive 서브모듈까지 모두 업데이트(pull) # # 모든 서브모듈에 대해 동일한 명령어를 수행하고 싶을 때 git submodule foreach [명령어] # 모든 서브모듈에 대해 git pull git submodule foreach git pull origin master 또는\ngit submodule update --remote --merge 서브모듈 위치 이동 # 그냥 디렉토리였으면 이동하고 커밋하면 되지만, 서브모듈일때는 아래 명령어만 치면 된다.\n그럼.gitmodules까지 모두 수정해준다.\n$ git mv {기존모듈경로} {새로운모듈경로} "},{"id":67,"href":"/docs/mystudy/algorithm-note/prime_number_code/","title":"소수 관련 코드","section":"Algorithm Note","content":" 소수 여부 확인 # def is_prime(n): if n==1: return False for d in range(2, int(n**0.5)+1): if n%d==0: return False return True 약수 구하기 # def solution(n): answer = set() for d in range(1, int(n**0.5)+1): if n%d==0: answer.add(d) answer.add(n//d) return sorted(list(answer)) 최대공약수와 최소공배수 # math 사용 import math math.gcd(a, b) # 최대공약수 math.lcm(a, b) # 최소공배수 직접 구현 # 자연수 a, b의 최대공약수 구하는 함수 def gcd(a, b): if b==0: return a else: return gcd(b, a%b) # 자연수 a, b의 최소공배수 구하는 함수 def lcm(a, b): return a*b//gcd(a,b) "},{"id":68,"href":"/docs/memo/freq-used-code/time/","title":"시간 측정 python","section":"자주 쓰는 코드들","content":" 코드 시간 측정하기 # import time start = time.time() ### 실행코드 ### end = time.time() print(end-start) # 초단위 "},{"id":69,"href":"/docs/memo/commands/linux/zip_tar_gz/","title":"압축 관련","section":"Linux","content":" 압축 해제 # tar -zxvf [압축파일] -C [폴더이름] "},{"id":70,"href":"/docs/memo/commands/poetry/dependency/","title":"의존성 관련","section":"Poetry","content":" poetry 그룹에 의존성 추가 # poetry add {패키지} --group {그룹명} poetry 버전 지정하여 의존성 추가 # poetry add \u0026#34;\u0026lt;패키지\u0026gt;\u0026lt;버전표기\u0026gt;\u0026#34; # 예 poetry add \u0026#34;selenium^4.10.0\u0026#34; # 가장 최신 버전 설치할 때 poetry add {패키지}@latest 버전 표기법 # ^1.2.3 : \u0026gt;=1.2.3 \u0026lt;2.0.0 ^1.2 : \u0026gt;=1.2.0 \u0026lt;2.0.0 ~2.0.5 : \u0026gt;=2.0.5, \u0026lt;2.1.0 \u0026gt;=2.0.5 ==2.0.5 설치된 모든 패키지 확인 # poetry show # 특정패키지를 지정 poetry show {패키지} # 의존성 트리 poetry show --tree 의존성 꼬였을 때 # 가상환경 삭제 poetry env remove --all pyproject.toml 삭제 재설치 poetry install Ref # https://python-poetry.org/docs/cli/\n"},{"id":71,"href":"/docs/mystudy/algorithm-note/part2/5_dfs_bfs/datastructure/","title":"자료구조 기초","section":"5. DFS \u0026 BFS","content":" 자료구조 기초 # 탐색 # 많은 양의 데이터 중 원하는 데이터를 찾는 과정 그래프, 트리 등의 자료구조 안에서 탐색하는 문제를 자주 다룸. 대표적인 탐색 알고리즘으로 DFS, BFS를 꼽을 수 있다. 자료구조 # 데이터를 표현하고 관리하고 처리하기 위한 구조 스택과 큐는 자료구조의 기초개념으로 \u0026ldquo;삽입\u0026rdquo;, \u0026ldquo;삭제\u0026rdquo; 의 두 핵심 함수로 구성됨 스택 : 선입후출 / 후입선출 큐 : 선입선출 구조 재귀함수 컴퓨터 내부에서 재귀함수의 수행은 스택 자료구조를 이용 (가장 마지막에 호출한 함수가 먼저 수행을 끝내야 그 앞의 함수 호출이 종료되기 때문에) 스택 자료구조를 활용해야 하는 상당 수 알고리즘은 재귀 함수를 이용해 간편하게 구현될 수 있다. (ex. DFS) 그래프 # 노드 Node 와 간선 Edge 으로 표현되며, 노드를 정점(Vertex)이라고도 한다. 그래프 탐색이란 하나의 노드를 시작으로 다수의 노드를 방문하는 것을 말함. 프로그래밍에서 그래프는 크게 2가지 방식으로 표현할 수 있다. 인접행렬 : 2차원 배열로 그래프의 연결관계를 표현하는 방식 인접 리스트 : 리스트로 그래프의 연결관계를 표현하는 방식 \u0026ldquo;연결 리스트\u0026quot;라는 자료구조 이용 python에서 연결리스트를 이용해 그래프를 표현하고자 할 때에도 단순히 2차원 리스트를 이용하면 됨. 인접 행렬 방식 예제\nINF = 999999999 graph = [ [0, 7, 5], [7, 0, INF], [5, INF, 0] ] print(graph) 인접 리스트 방식 예제\ngraph = [[] for _ in range(3)] # 노드 0에 연결된 노드 정보 (노드, 거리) graph[0].append((1, 7)) graph[0].append((2, 5)) # 노드 2에 연결된 노드 정보 (노드, 거리) graph[1].append((0, 7)) # 노드 2에 연결된 노드 정보 (노드, 거리) graph[2].append((0, 5)) print(graph) 인접 행렬과 인접 리스트 방식의 차이 메모리 측면에서 인접 행렬 방식은 노드 개수가 많을수록 메모리가 불필요하게 낭비되지만, 인접리스트 방식은 메모리를 효율적으로 사용함. 인접리스트 방식은 인접 행렬 방식에 비해 두 노드가 연결되어 있는지에 대한 정보를 얻는 속도가 느림. "},{"id":72,"href":"/docs/memo/commands/","title":"자주 쓰는 명령어들","section":"메모장","content":" Git 관련 # commit 취소\ncredentail 관련\nclone 관련\n최초 설정 관련\nLinux # 파일 생성/이동/복사/삭제\n백그라운드 관련 명령어\nUbuntu Screen 명령어\nGPU 관련\n압축해제\nconda # 가상환경 관련\nPoetry # Poetry 시작하기\n가상환경 관련\n의존성 관련\n내보내기(requirements.txt)\n기타 # python3의 venv 사용법\npython3 서버열기\npython의 인자값 받기\nDocker 명령어\nVSCode 단축키\n터미널 테마\n"},{"id":73,"href":"/docs/memo/freq-used-code/","title":"자주 쓰는 코드들","section":"메모장","content":" 간단한 히스토그램 python import matplotlib.pyplot as plt plt.hist(data, bins=bin_num) import matplotlib.pyplot as plt import numpy as np cnts, bins = np.histogram(data, bin_num) plt.his(data, bins) 경고 무시 python python 경고 무시하기 # import warnings warnings.filterwarnings(action=\u0026#39;ignore\u0026#39;) 시간 측정 python 코드 시간 측정하기 # import time start = time.time() ### 실행코드 ### end = time.time() print(end-start) # 초단위 파일 압축 python 파일 압축 # import zipfile zf = zipfile.ZipFile(\u0026#39;.//foldername//filename.zip\u0026#39;, \u0026#39;w\u0026#39;) zf.write(\u0026#39;filepath\u0026#39;) # compress_type=zipfile.ZIP_DEFLATED zf.close() 압축 해제 후 DataFrame으로 변환 # import zipfile from pyarrow import csv zf = zipfile.ZipFile(\u0026#39;..//foldername//filename.zip\u0026#39;, \u0026#39;r\u0026#39;) df = csv.read_csv(zf.open(\u0026#39;content_hit-2021.03.csv\u0026#39;)).to_pandas() 파일 읽기 python 내장함수 open으로 파일 읽기 (txt, csv, json) # readline readline( ) 함수 사용 # 제너레이터처럼 한줄씩 꺼내서 str 타입으로 읽어들인다. (txt, csv, json 파일도 가능) f = open(\u0026#34;d:\\\\data\\\\emp3.csv\u0026#34;, \u0026#34;r\u0026#34;) file = [] while True: line = f.readline() # readline: 한줄씩 읽어들임 if not line: break file.append(line) # readline: 한줄을 문자열로 반환 f.close() print(file) # file : [ str, str, ..., str ] 의 형태 readlines readlines( ) 함수 사용 # readline( ) 함수와는 다르게 list 타입으로 반환한다. "},{"id":74,"href":"/docs/memo/commands/git/initial_setup/","title":"초기설정 관련","section":"Git 관련","content":" 모든 설정값 확인 # git config --list 특정값 확인\ngit config user.name 모든 설정값과 해당 위치 확인 # git config --list --show-origin 사용자 이름 및 이메일 설정 # git config --global user.name \u0026#34;\u0026lt;사용자ID\u0026gt;\u0026#34; git config --global user.email {이메일} * global 옵션을 전달할 경우 한번만 수행해도 된다.\n설정값 지우기 # git config --unset user.name git config --unset user.email git config --unset --global user.name git config --unset --global user.email * global로 설정한 경우, global로 지워야 한다.\n편집기 설정 # git config global core.editor emacs git config --global core.editor \u0026#34;\u0026#39;C:/Program Files/Notepad++/notepad++.exe\u0026#39; -multiInst -notabbar -nosessin -noPlugin\u0026#34; * Windows 시스템에서 다른 텍스트 편집기를 사용하려면 실행파일의 전체 경로를 지정해야 함.\n기본 Branch 설정 # git config --global init.defaultBranch main "},{"id":75,"href":"/docs/memo/commands/etc/terminal_theme/","title":"터미널 테마","section":"Etc","content":" 터미널 테마 바꾸기 # https://terminalsplash.com/\n"},{"id":76,"href":"/docs/memo/commands/linux/file_dir/","title":"파일 생성/이동/복사/삭제","section":"Linux","content":" 파일 이동 # mv \u0026lt;이동전 파일 path\u0026gt; \u0026lt;이동후 파일 path\u0026gt; mv /home/index.html /home/test/index.html 파일 복사 # cp \u0026lt;복사전 파일 path\u0026gt; \u0026lt;복사후 파일 path\u0026gt; cp /home/index.html /home/test/index.html 디렉토리 이동 # mv \u0026lt;원본폴더\u0026gt; \u0026lt;목적지폴더\u0026gt; 디렉토리 복사 # cp -r \u0026lt;복사전 dir_path\u0026gt; \u0026lt;복사될 상위 dir_path\u0026gt; cp -r /home/index /home/test # home/test/index 폴더가 생성됨 디렉토리 생성 # mkdir \u0026lt;디렉토리명\u0026gt; 옵션 -m : 폴더 권한 설정 파일 삭제 # rm \u0026lt;파일명\u0026gt; 디렉토리 삭제 # rm -r \u0026lt;파일명\u0026gt; -r 옵션: recursive, 폴더를 지우거나 폴더 안의 파일을 전부 지울 때 -f 옵션 : 진짜로 지울거냐는 확인 없이 강제로 지움. "},{"id":77,"href":"/docs/memo/freq-used-code/file_zip/","title":"파일 압축 python","section":"자주 쓰는 코드들","content":" 파일 압축 # import zipfile zf = zipfile.ZipFile(\u0026#39;.//foldername//filename.zip\u0026#39;, \u0026#39;w\u0026#39;) zf.write(\u0026#39;filepath\u0026#39;) # compress_type=zipfile.ZIP_DEFLATED zf.close() 압축 해제 후 DataFrame으로 변환 # import zipfile from pyarrow import csv zf = zipfile.ZipFile(\u0026#39;..//foldername//filename.zip\u0026#39;, \u0026#39;r\u0026#39;) df = csv.read_csv(zf.open(\u0026#39;content_hit-2021.03.csv\u0026#39;)).to_pandas() "},{"id":78,"href":"/docs/memo/freq-used-code/file_open/","title":"파일 읽기 python","section":"자주 쓰는 코드들","content":" 내장함수 open으로 파일 읽기 (txt, csv, json) # readline readline( ) 함수 사용 # 제너레이터처럼 한줄씩 꺼내서 str 타입으로 읽어들인다.\n(txt, csv, json 파일도 가능)\nf = open(\u0026#34;d:\\\\data\\\\emp3.csv\u0026#34;, \u0026#34;r\u0026#34;) file = [] while True: line = f.readline() # readline: 한줄씩 읽어들임 if not line: break file.append(line) # readline: 한줄을 문자열로 반환 f.close() print(file) # file : [ str, str, ..., str ] 의 형태 readlines readlines( ) 함수 사용 # readline( ) 함수와는 다르게 list 타입으로 반환한다.\n반복문을 사용하지 않아도 된다.\nf = open(\u0026#39;d:\\\\data\\\\emp3.csv\u0026#39;, \u0026#39;r\u0026#39;) file = f.readlines() f.close() # [ str, str, ..., str ] read read( ) 함수 사용 # 파일 전체를 str 타입으로 반환\nf = open(\u0026#39;d:\\\\data\\\\emp3.csv\u0026#39;, \u0026#39;r\u0026#39;) file = f.read() # 전체 str 형태로 반환 f.close() with with문 사용하기 # with open(\u0026#39;d:\\\\data\\\\emp3.csv\u0026#39;, \u0026#39;r\u0026#39;) as f: file = f.read() # str with open(\u0026#39;d:\\\\data\\\\emp3.csv\u0026#39;, \u0026#39;r\u0026#39;) as f: file = f.readlines() # file : [ str, str, ..., str ] 이미지 파일 # PIL PIL 라이브러리 사용해서 읽기 # from PIL import Image img = Image.open(\u0026#39;파일경로\u0026#39;) img.show() numpy PIL.Image, numpy, matplotlib을 사용해서 읽기 # import PIL.Image as pilimg import numpy as np import matplotlib.pyplot as plt im = pilimg.open(\u0026#39;파일경로\u0026#39;) pix = np.array(im) plt.imshow(pix) 저장 PIL 라이브러리 사용해서 저장 # from PIL import Image img = Image.open(\u0026#39;파일경로\u0026#39;) img.save(\u0026#39;파일경로\u0026#39;) csv 파일 # pandas pandas 라이브러리 사용 # import pandas as pd emp = pd.read_csv(\u0026#34;d:\\\\data\\\\emp3.csv\u0026#34;) csv csv 라이브러리 사용 # import csv file = open(\u0026#39;D:\\\\data\\\\emp2.csv\u0026#39;, \u0026#39;r\u0026#39;) emp_csv = csv.reader(file) # csv.reader: 주소값이 반환됨 for emp_list in emp_csv: # 하나씩 출력해야 함 print( emp_list ) pyarrow pyarrow 라이브러리 사용 # 파일 용량이 커서 pandas나 csv로 열 수 없을 때, pyarrow를 사용하면 좋다.\n속도도 더 빠르다.\nimport pandas as pd from pyarrow import csv tb = csv.read_csv(\u0026#39;csv파일 경로\u0026#39;) df = tb.to_pandas() json 파일 # json이란\nimport json jdata = [json.loads(i) for i in jdata] # jdata: [str, ... , str] print( type(jdata) ) =\n"}]